Haskell ä¸»è¦ä½¿ç”¨ data ä¸ newtype å…³é”®å­—æ¥å®šä¹‰æ–°çš„ç±»å‹ã€‚

å®šä¹‰æ–°çš„ç±»å‹åï¼Œå¯èƒ½ä¼šå‘ç°è¿™äº›ç±»å‹ä¸ä¹‹å‰ç”¨è¿‡çš„ç±»å‹æ˜¯ç­‰ä»·çš„ï¼Œè¿™ç§ç­‰ä»·ç§°ä¸ºåŒæ„ï¼ˆisomorphismï¼‰ã€‚

## æ•°æ®ç±»å‹çš„å®šä¹‰

### æšä¸¾ç±»å‹

å¸ƒå°”ç±»å‹åœ¨ Haskell ä¸­å°±æ˜¯æšä¸¾å®šä¹‰çš„ï¼Œè¿™ä¸ªç±»å‹é‡Œåªæœ‰ä¸¤ä¸ªå€¼ï¼Œå³ True ä¸ Falseã€‚

åœ¨ Prelude ä¸­å®ƒæ˜¯è¿™æ ·å®šä¹‰çš„ï¼š

```haskell
data Bool = False | True 
```

**data** æ˜¯å®šä¹‰æ–°ç±»å‹çš„å…³é”®å­—ï¼Œåè¾¹è·Ÿæƒ³è¦å®šä¹‰çš„ç±»å‹åç§°ï¼Œç±»å‹åç§°é¦–å­—æ¯è¦å¤§å†™ã€‚ç„¶å**å®šä¹‰å¸ƒå°”ç±»å‹çš„å€¼ï¼Œå³ True ä¸ False**ã€‚

å¸ƒå°”ç±»å‹æ˜¯ä¸€ä¸ªéå¸¸ç®€å•çš„ç±»å‹ï¼Œè¿™ä¸ªç±»å‹åªå¯èƒ½æœ‰ä¸¤ä¸ªå€¼ï¼Œä¹Ÿå¯ä»¥ç§°ä¸ºä¸¤ç§å½¢å¼ï¼ŒTrue æˆ–è€… Falseã€‚è¿™é‡Œåªéœ€è¦å°†å®ƒä»¬ä¸€æ¬¡å†™å‡ºï¼Œç”¨ "|"åˆ†å¼€å³å¯ã€‚è¿™ç§å®šä¹‰çš„æ–¹å¼å¯ä»¥è¢«ç§°ä¸ºæšä¸¾å®šä¹‰ï¼Œå³å®šä¹‰çš„å€¼èƒ½å¤Ÿä»¥ä¸€å®šçš„é¡ºåºä¸€ä¸€åœ°æšä¸¾å‡ºæ¥ã€‚ä½¿ç”¨æ¨¡å¼åŒ¹é…å®šä¹‰å‡½æ•°æ—¶å°±æ˜¯åŒ¹é… "|"ä¹‹é—´ä¸åŒçš„å®šä¹‰æ¨¡å¼ã€‚

å®šä¹‰â€œæ˜ŸæœŸâ€ç±»å‹

```haskell
-- è¿™é‡Œå¯ä»¥å…ˆä½¿ç”¨ deriving å…³é”®å­—æ¥è®©è¿™ä¸ªç±»å‹è‡ªåŠ¨å®ç°ä¸€äº›ç±»å‹ç±»

data Day = Mon | Tue | Wed | Thu | Fri | Sat | Sun
 deriving (Show, Eq, Ord, Enum)
 
 -- å®ç°äº†Showç±»å‹ç±»
 >>> Mon
Mon

-- å®ç°äº†Eqç±»å‹ç±»
>>> Mon == Mon
True

-- å®ç°äº†Ordç±»å‹ç±»
-- ç”±äºæœ‰åºç±»å‹ç±»Ordæ˜¯åŸºäºç›¸ç­‰ç±»å‹ç±» Eq çš„ï¼Œå› æ­¤ä¸€å®šè¦å®ç°ç›¸ç­‰ç±»å‹ç±» Eq åæ‰èƒ½å®ç°æœ‰åºç±»å‹ç±» Ord 
>>> Mon < Sun
True

-- å®ç°äº†Enum ç±»å‹ç±»
>>> [Mon .. Sun]
[Mon,Tue,Wed,Thu,Fri,Sat,Sun]

-- é€šè¿‡æ¨¡å¼åŒ¹é…å®ç° tomorrow å‡½æ•°
-- è¿™ä¸ª tomorrow å‡½æ•°çš„å®ç°æ¯”è¾ƒéº»çƒ¦
tomorrow :: Day -> Day
tomorrow Mon = Tue
tomorrow Tue = Wed
tomorrow Wed = Thu
tomorrow Thu =Fri
tomorrow Fri =Sat
tomorrow Sat =Sun
tomorrow Sun = Mon

{--
ç”±äºç±»å‹ Day å®ç°äº†æšä¸¾ç±»å‹ç±» Enum åï¼Œæœ‰å¾ˆå¤šå‡½æ•°å¯ä»¥ç«‹å³ä½¿ç”¨ï¼Œå¦‚ succã€ pred åŠå…¶ä»–çš„å‡½æ•°ï¼Œè¿™é‡Œç®€å•ä»‹ç»  succ ï¼ˆsuccessorçš„ç®€å†™ï¼‰å‡½æ•°ä¸ pred (predecessor çš„ç®€å†™)å‡½æ•°ã€‚succ å‡½æ•°ä¼šè¿”å›å‚æ•°çš„ä¸‹ä¸€ä¸ªæšä¸¾ç±»å‹çš„å€¼ï¼Œè€Œ pred ä¼šè¿”å›ç»™å®šå‚æ•°çš„å‰ä¸€ä¸ªæšä¸¾ç±»å‹çš„å€¼ã€‚
--}
-- å¦‚æœç»™å®šçš„å‚æ•°å·²ç»ä¸ºè¾¹ç•Œå€¼ï¼Œåˆ™ä¼šå‡ºç°å¼‚å¸¸
tomorrow' :: Day -> Day
tomorrow' Sun = Mon
tomorrow' day = succ day
```

é™¤äº†ä»¥ä¸Šçš„ 4 ä¸ªæ¯”è¾ƒå¸¸ç”¨çš„ç±»å‹ç±»ï¼Œè¿˜æœ‰å¯è¯»ç±»å‹ç±» Readï¼Œå³å¯ä»¥ä½¿ç”¨ read å‡½æ•°æ¥å°†ä¸€ä¸ªå­—ç¬¦ä¸²è¯»æˆ Day çš„ç±»å‹çš„æ•°æ®ã€‚

```haskell
data Day = Mon | Tue | Wed | Thu | Fri | Sat | Sun
 deriving (Show, Read)
 
 >>> read "Mon" :: Day 
Mon
```

å€¼å¾—ä¸€æçš„æ˜¯ï¼Œå¦‚æœä¸€ä¸ªæ•°æ®ç±»å‹ a æ˜¯å¯è¯»çš„ï¼Œé‚£ä¹ˆä¾èµ–äº a çš„ç±»å‹ b ä¹Ÿæ˜¯å¯è¯»çš„ã€‚æ¯”å¦‚ï¼Œæ•°æ® Day æ˜¯å¯è¯»çš„ï¼Œä»¥æ¥äº Day ç±»å‹çš„åˆ—è¡¨ [Day] ä¹Ÿæ˜¯å¯è¯»çš„ã€‚

```haskell
>>> read "[Mon, Tue]" :: [Day]
[Mon,Tue]
```

### æ„é€ ç±»å‹

```haskell
-- æ„é€  Book ç±»å‹
type Name = String
type Author = String
type ISBN = String
type Price = Float

data Book = Book Name Author ISBN Price deriving(Show, Eq)
```

data Book ä¸­çš„ Bookæ˜¯ç±»å‹çš„åç§°ï¼Œä¹Ÿç§°ä¸º**ç±»å‹æ„é€ å™¨**ï¼ˆ*ç±»å‹æ„é€ å™¨å¯ä»¥æœ‰ç±»å‹å‚æ•°ï¼Œå³å‚æ•°åŒ–ç±»å‹*ï¼‰ã€‚

Book Name Author ISBNä¸­çš„ Book ç§°ä¸º**æ•°æ®æ„é€ å™¨**ï¼ˆdata constructorï¼‰ã€‚

è™½ç„¶åœ¨å¾ˆå¤šç±»å‹çš„å®šä¹‰ä¸­ç±»å‹çš„åç§°ä¸æ•°æ®æ„é€ å™¨çš„åç§°æ˜¯ç›¸åŒçš„ï¼Œä½†ç»ä¸èƒ½æ··æ·†ç±»å‹æ„é€ å™¨å’Œæ•°æ®æ„é€ å™¨ï¼Œã€‚

å…¶å®ï¼Œæ•°æ®æ„é€ å™¨æœ¬èº«æ˜¯ä¸€ç§ç‰¹æ®Šçš„å‡½æ•°ï¼Œä¸è¿‡é¦–å­—æ¯ä¼šå¤§å†™ã€‚

```haskell
-- é€šè¿‡æŸ¥çœ‹ Book çš„ç±»å‹å¯ä»¥çŸ¥é“ï¼Œæ„é€ å™¨æœ¬è´¨ä¸Šæ˜¯ä»¥é‚£äº›å‡½æ•°ä½œä¸ºè¾“å…¥ï¼Œè¿”å›ä¸€ä¸ª Book ç±»å‹çš„æ•°æ®çš„å‡½æ•°
>>> :t Book
Book :: Name -> Author -> ISBN -> Price -> Book

--è®¿é—®ç±»å‹ä¸­çš„å‚æ•°
name   (Book n _ _ _) = n
author (Book _ a _ _) = a
isbn   (Book _ _ i _) = i
price  (Book n _ _ p) = p

>>> name $ Book  "Haskell" "Mark" "45678" 10
"Haskell"
```

Haskell æä¾›äº†å¦ä¸€ç§å®šä¹‰çš„è¯­æ³•ï¼Œè¿™ä¸ªè¯­æ³•ä½¿å¾—è®¿é—®å™¨å‡½æ•°è½½è¿™ä¸ªç±»å‹å®šä¹‰çš„åŒæ—¶ä¹Ÿè¢«å®šä¹‰å‡ºæ¥äº†ã€‚

```haskell
data Book = Book {
         name :: Name,
         author :: Author ,
         isbn :: ISBN,
         price :: Price
       } deriving(Show, Eq)
```

è®¿é—®å™¨çš„åç§°å¦‚ nameã€author ç­‰ï¼Œè¢«ç§°ä¸º**å­—æ®µå**æˆ–è€…**è®°å½•(record)**ã€‚

ç”±äºæ˜¯è®¿é—®Bookçš„å‡½æ•°ï¼Œæ‰€ä»¥è¿™äº›å‡½æ•°éƒ½éœ€è¦ä¸€ä¸ªBook ç±»å‹çš„å€¼ä½œä¸ºå‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°ã€‚

```haskell
>>> :t name
name :: Book -> Name

>>> :t author
author :: Book -> Author
```



```haskell
-- ä¹¦åº—ä¸­çš„ä¸€äº›ä¹¦è¦æ¶¨ä»·ï¼Œä¹¦åº—éœ€è¦åˆ†åˆ«è®°å½•åŸä»·å’Œæ¶¨ä»·åä¹¦çš„ä¿¡æ¯
incrisePrice :: ([Book], [Book]) -> Book -> Float -> ([Book], [Book])
incrisePrice (b1, b2) b pri = ((b: b1), (Book (name b) (author b) (isbn b) (price b + pri)) : b2)

>>> incrisePrice ([(Book  "Haskell" "Mark" "45678" 10)],[]) (Book  "Scheme" "Jim" "654" 100) 150

([Book {name = "Scheme", author = "Jim", isbn = "654", price = 100.0},Book {name = "Haskell", author = "Mark", isbn = "45678", price = 10.0}],[Book {name = "Scheme", author = "Jim", isbn = "654", price = 250.0}])

-- é‡æ„ç‰ˆæœ¬1
incrisePrice (b1, b2) (Book nm ath isbn prc) pri = ((Book nm ath isbn prc):b1, (Book nm ath isbn (prc+pri)):b2)

-- é‡æ„ç‰ˆæœ¬2ï¼Œä½¿ç”¨@ç¬¦å·æ¥ç”¨ä¸€ä¸ªåå­—æ¥æŒ‡ä»£è¿™ä¸ªæ„é€ çš„æ•°æ®
incrisePrice (b1, b2) b@(Book nm ath isbn prc) pri = (b:b1, (Book nm ath isbn (prc+pri)):b2)

-- é‡æ„ç‰ˆæœ¬3
incrisePrice (b1, b2) b pri = (b:b1, (b{price=pri}):b2)
```
ä¸Šé¢è®¨è®ºçš„ Book æ•°æ®æ„é€ å™¨æ˜¯éœ€è¦ä¸€äº›å…¶å®ƒå‚æ•°å¡«å……çš„ï¼Œè€Œæœ‰çš„æ—¶å€™ï¼Œæ„é€ å™¨ä¸å€¼å…¶å®å¹¶æ²¡æœ‰æ˜¾è‘—çš„åŒºåˆ«ï¼Œæ¯”å¦‚ï¼Œå¯ä»¥è®¤ä¸º True ä¸ False å°±æ˜¯å¸ƒå°”ç±»å‹çš„æ„é€ å™¨ï¼Œå®ƒä»¬ä¸éœ€è¦å‚æ•°ç§°ä¸º**é›¶å…ƒæ•°æ®æ„é€ å™¨**ï¼ˆ**nullary data constructor**ï¼‰ã€‚

### å‚æ•°åŒ–ç±»å‹

**å‚æ•°åŒ–ç±»å‹æ˜¯éœ€è¦ç±»å‹å‚æ•°çš„ç±»å‹**ã€‚å‚æ•°åŒ–ç±»å‹çš„å®šä¹‰ä¸­çš„ç±»å‹åç§°åå¯ä»¥åŠ ä¸€ä¸ªä»»æ„çš„ç±»å‹å‚æ•°ä»¥ä¾›è¿™ä¸ªç±»å‹çš„æ•°æ®æ„é€ å™¨ä½¿ç”¨ï¼Œè¿™æ ·çš„æ„é€ å™¨å¯ä»¥æš‚æ—¶ç®€å•ç†è§£ä¸ºä¸€ä¸ªå®¹å™¨ï¼Œä¸æ„é€ ç±»å‹ä¸åŒï¼Œè¿™é‡Œçš„å‚æ•°å¯ä»¥æ˜¯ä»»ä½•çš„å¤šæ€ç±»å‹ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªç¡®å®šçš„ç±»å‹ã€‚

```haskell
data Maybe a = Nothing | Just a
```

Maybeå¯ä»¥ç†è§£ä¸ºä¸€ç§å®¹å™¨ç±»å‹ï¼Œé‡Œé¢å¯ä»¥æ”¾ä¸€äº›ä¸œè¥¿ã€‚Just å†…çš„ç±»å‹ a å¯ä»¥æ˜¯ä»»æ„çš„ç±»å‹ï¼ŒFloatã€Doubleã€å…ƒç»„ ç”šè‡³æ˜¯å‡½æ•°ç±»å‹ã€‚è¿™é‡Œ Just å°±æ˜¯ä¸€ä¸ªæ„é€ å™¨ï¼Œè¿™ä¸ªæ„é€ å™¨æ˜¯ä¸€ä¸ªå •èƒç±»å‹çš„å‡½æ•°ï¼Œå®ƒçš„ç±»å‹æ˜¯ a -> Maybe a

```haskell
>>> :i Maybe
data Maybe a = Nothing | Just a         -- Defined in â€˜GHC.Baseâ€™
instance Eq a => Eq (Maybe a) -- Defined in â€˜GHC.Baseâ€™
instance Monad Maybe -- Defined in â€˜GHC.Baseâ€™
instance Functor Maybe -- Defined in â€˜GHC.Baseâ€™
instance Ord a => Ord (Maybe a) -- Defined in â€˜GHC.Baseâ€™
instance Read a => Read (Maybe a) -- Defined in â€˜GHC.Readâ€™
instance Show a => Show (Maybe a) -- Defined in â€˜GHC.Showâ€™
instance Applicative Maybe -- Defined in â€˜GHC.Baseâ€™
instance Foldable Maybe -- Defined in â€˜Data.Foldableâ€™
instance Traversable Maybe -- Defined in â€˜Data.Traversableâ€™
instance Monoid a => Monoid (Maybe a) -- Defined in â€˜GHC.Baseâ€™
```

Maybeç±»å‹å®ç°äº† Eqã€Ordã€Readã€Show ç±»å‹ç±»ã€‚

å¦‚æœ a å¯ä»¥æ¯”è¾ƒç›¸ç­‰ï¼Œé‚£ä¹ˆ Maybe a ä¹Ÿå¯ä»¥æ¯”è¾ƒç›¸ç­‰ã€‚

```haskell
>>> Nothing < Just 3
True

{-
è¿™é‡Œé”™è¯¯çš„æ„æ€æ˜¯ï¼Œå‡½æ•°çš„ç±»å‹æ²¡æœ‰å®ç°æœ‰åºç±»ï¼Œæ‰€ä»¥ä¸èƒ½ä½¿ç”¨ < è¿›è¡Œæ¯”è¾ƒï¼Œåœ¨ä»»ä½•è¯­è¨€ä¸­å‡½æ•°éƒ½æ˜¯æ— æ³•ç›´æ¥æ¯”è¾ƒç›¸ç­‰è¿˜æœ‰å¤§å°çš„ã€‚
å¦‚æœæœ‰è¯­è¨€æ¯”è¾ƒäº†å‡½æ•°çš„ç›¸ç­‰ï¼Œå®ƒæ¯”è¾ƒçš„ä¸€åŠæ˜¯å‡½æ•°çš„æ‰€åœ¨åœ°å€æˆ–è€…ç¼–è¯‘æˆçš„æŒ‡ä»¤ï¼Œå³æ— æ³•æ¯”å½’å¹¶æ’åºä¸å†’æ³¡æ’åºä¸å¦ã€‚
-}
>>> Nothing < Just (+)
    â€¢ No instance for (Ord (a0 -> a0 -> a0)) arising from a use of â€˜<â€™
        (maybe you haven't applied a function to enough arguments?)
    â€¢ In the expression: Nothing < Just (+)
      In an equation for â€˜itâ€™: it = Nothing < Just (+)
      
>>> read "Just 5" :: Maybe Int
Just 5

>>> show $ Just 5
"Just 5"
```

Maybeç±»å‹æœ‰ä»€ä¹ˆä½œç”¨å‘¢ï¼Ÿç®€å•åœ°è¯´ï¼ŒMaybe ç±»å‹æ˜¯ä¸€ç§ç®€å•çš„ç¨‹åºå¤„ç†å¼‚å¸¸çš„æ–¹å¼ï¼Œå› ä¸ºæœ‰äº›æ—¶å€™ï¼Œç¨‹åºéœ€è¦å¸¦ç€å‡ºç°çš„å¼‚å¸¸ç»§ç»­è¿è¡Œï¼Œè€Œä¸æ˜¯ç®€å•åœ°ä¹…æŠ›å‡ºå¼‚å¸¸ç„¶åç»ˆæ­¢ã€‚å½“å‡ºç°å¼‚å¸¸çš„æ—¶å€™ï¼Œè¿”å› Nothingï¼Œæ¯”å¦‚ï¼ŒHead [] çš„æ—¶å€™å°±æŠ›å‡ºå¼‚å¸¸ã€‚

```haskell
>>> head []
*** Exception: Prelude.head: empty list

-- ä½¿ç”¨ Maybe æ¥å†™ä¸€ä¸ªä¸å‡ºç°å¼‚å¸¸çš„ã€å®‰å…¨çš„ head å‡½æ•°
safeHead :: [a] -> Maybe a
safeHead [] = Nothing
safeHead (x:xs) = Just x
```

#### ç±»å‹æ„é€ å™¨

**åƒ Maybe éœ€è¦å…¶å®ƒç±»å‹ä½œä¸ºå‚æ•°æ¥æ„é€ ä¸€ä¸ªæ–°çš„ç±»å‹çš„ç±»å‹ï¼Œè¢«ç§°ä¸ºç±»å‹æ„é€ å™¨ï¼ˆtype constructorï¼‰ã€‚**

**ç±»å‹çš„ç±»å‹ç§°ä¸º kind**ã€‚

\* æ˜¯ä¸€ä¸ªé›¶å…ƒç±»å‹æ„é€ å™¨ï¼ˆnullary type constructorï¼‰çš„ kindï¼Œè¿™ç§ç±»å‹æ„é€ å™¨ä¸éœ€è¦å…¶å®ƒç±»å‹åšä¸ºå‚æ•°ï¼Œè‡ªå·±æœ¬èº«å°±æ˜¯ä¸€ä¸ªâ€œå®Œæ•´çš„â€ç±»å‹ï¼Œæ¯”å¦‚ï¼Œ Maybe Bool :: * ä¸ Maybe Int :: * éƒ½æ˜¯å®Œæ•´çš„ç±»å‹ã€‚

Haskell ä¸­åœ¨ GHCi é‡Œä½¿ç”¨ :kindï¼ˆç®€å†™ä¸º:kï¼‰ æ¥æŸ¥è¯¢ä¸€ä¸ªç±»å‹æ„é€ å™¨çš„ kind ã€‚

```haskell
>>> :k Int
Int :: *

>>> :k Maybe
Maybe :: * -> *

{-
Maybe Int æ˜¯ä¸€ä¸ªä¸éœ€è¦å…¶å®ƒç±»å‹è¾“å…¥çš„kindã€‚
è¿™é‡Œçš„ Int ç±»å‹è¢«åº”ç”¨åˆ°äº† Maybe ç±»å‹æ„é€ å™¨ï¼Œç§°ä¸ºå®ƒçš„å‚æ•°æ›¿æ¢äº†ç¬¬ä¸€ä¸ªæ˜Ÿå·ä»è€Œå¾—åˆ°äº†ä¸€ä¸ªå®Œæ•´çš„ç±»å‹ã€‚
è¿™ä¸å‡½æ•°è½½åº”ç”¨æ—¶ï¼Œå‚æ•°çš„ç±»å‹æ›¿æ¢äº†å‡½æ•°ç±»å‹ç­¾åä¸­ç®­å¤´å‰çš„ç±»å‹æ˜¯ä¸€æ ·çš„é“ç†ã€‚ 
-}
>>> :k Maybe Int
Maybe Int :: *
```

é™¤äº† Maybe å¤–ï¼ŒHaskell é¢„åŠ è½½åº“ä¸­å¦å¤–ä¸€ä¸ªé‡è¦ç±»å‹æ˜¯ Eitherï¼Œç§°ä¸º â€œæˆ–è€…â€ ç±»å‹ã€‚å®ƒéœ€è¦ä¸¤ä¸ªä¸åŒçš„ç±»å‹ä½œä¸ºè¾“å…¥ï¼Œç»„åˆæˆä¸€ä¸ªæ–°çš„ç±»å‹ã€‚å¸¸å¸¸åŒæ—¶éœ€è¦ä¸€ç§ç±»å‹æˆ–å¦ä¸€ç§ç±»å‹çš„æ—¶å€™ç”¨åˆ°ã€‚

**Either æ˜¯ä¸€ç§éœ€è¦ä¸¤ä¸ªç±»å‹æ¥å…±åŒæ„æˆçš„ç±»å‹æ„é€ å™¨ã€‚Either çš„å®šä¹‰æ˜¯**ï¼š

```haskell
data Either a b = Left a | Right b 

>>> :k Either
Either :: * -> * -> *
```

ç›¸æ¯”äº Maybe ç±»å‹ï¼Œå¦‚æœç”¨Either æ¥å¤„ç†å¼‚å¸¸æœ‰æ—¶æ—¶ä¸€ä¸ªæ›´å¥½çš„é€‰æ‹©ï¼Œå› ä¸ºæˆ‘ä»¬ä¸ä½†å¯ä»¥çŸ¥é“è¿ç®—è¿‡ç¨‹æœ‰å¼‚å¸¸ï¼Œè¿˜å¯ä»¥å­˜å‚¨å¼‚å¸¸çš„ä¿¡æ¯ï¼Œè€Œ Maybe ä¸­ Nothingå´æ— æ³•åšåˆ°è¿™ä¸€ç‚¹ã€‚



åœ¨Haskell ä¸­ï¼Œå°†ä¸¤ä¸ªç±»å‹å¯èƒ½ä¸åŒçš„åˆ—è¡¨åˆæˆä¸€ä¸ªåˆ—è¡¨ã€‚

```haskell
disjoint :: [a] -> [b] -> [Either a b]
disjoint as bs = map Left as ++ map Right bs

>>> disjoint [1..5] ['a' ..'d'] 
[Left 1,Left 2,Left 3,Left 4,Left 5,Right 'a',Right 'b',Right 'c',Right 'd']

```

å½“éœ€è¦æŠŠEither ä¸­çš„å€¼æ˜ å°„ä¸ºå¦ä¸€ä¸ªå€¼æ—¶ï¼Œè¦ä¸º Left äº Right åˆ†åˆ«æä¾›ä¸€ä¸ªå‡½æ•°ï¼Œè¿™ä¸¤ä¸ªå‡½æ•°è¿”å›çš„ç±»å‹ç›¸åŒï¼Œåœ¨è¿™é‡Œéƒ½ä¸º c ç±»å‹ï¼š

```haskell
either :: (a -> c) -> (b -> c) -> Either a b -> c
either f _ (Left x) = f x
either _ g (Right y) = g y
```

ä¹Ÿå¯ä»¥å°†ä¸€ä¸ª Either ç±»å‹çš„åˆ—è¡¨åˆ†æˆä¸¤ä¸ªåˆ—è¡¨ï¼Œè¿™ä¸ªç›¸å½“äº disjoint çš„åå‡½æ•°ï¼š

```haskell
either' :: (a -> c) -> (b -> c) -> Either a b -> c
either' f _ (Left x) = f x
either' _ g (Right y) = g y

partitionEithers' :: [Either a b] -> ([a], [b])
partitionEithers' = foldr (either' left right) ([],[])
         where
              left  a (l, r) = (a:l ,r)
              right a (l, r) = (l, a:r)

>>> partitionEithers' [Left 1,Left 2,Left 3,Left 4,Left 5,Right 'a',Right 'b',Right 'c',Right 'd']
([1,2,3,4,5],"abcd")

```
```haskell
-- å’ŒäºŒå…ƒå…ƒç»„ (a, b) æ˜¯ç­‰ä»·çš„
data Pair a b = Pair a b

pfirst (Pair a b) = a
psecond (Pair a b) = b

>>> :t (,)
(,) :: a -> b -> (a, b)

-- (1, 2)
-- å¯ä»¥å†™æˆ (,) 1 2

>>> :t (,,)
(,,) :: a -> b -> c -> (a, b, c)

-- å…ƒç»„çš„æ•°æ®æ„é€ å™¨å¯ä»¥ä½¿ç”¨ TupleSections è¯­è¨€æ‰©å±•æ¥åšéƒ¨åˆ†åº”ç”¨
>>> :set -XTupleSections
>>> :t (,,5)
(,,5) :: Num t => t2 -> t1 -> (t2, t1, t)

-- å¾ˆæ˜¾ç„¶ï¼Œä¸‰å…ƒå…ƒç»„éœ€è¦3ä¸ªç±»å‹å‚æ•°é¤èƒ½è¿”å› * ï¼Œæ‰€ä»¥å®ƒçš„kindä¸º * -> * -> * -> *
>>> :k (,,)
(,,) :: * -> * -> * -> *
```

#### å‡½æ•°ç±»å‹

 a -> b  ä¸ºä¸€ä¸ªå‡½æ•°çš„ç±»å‹ï¼Œå®ƒä¹Ÿæ˜¯æœ‰ç±»å‹æ„é€ å™¨çš„ã€‚å®ƒçš„ç±»å‹æ„é€ å™¨æ˜¯ (->) ï¼Œä¹Ÿå¯ä»¥å†™ä½œ (->) a bã€‚ä½†å®ƒæ˜¯åµŒå…¥åœ¨Haskellä¸­çš„ï¼Œä¸æ˜¯ç›´æ¥å®šä¹‰çš„ï¼Œå®ƒçš„ kindä¸º *-> *-> *ã€‚

```haskell
>>> :k (->)
(->) :: * -> * -> *
```

å¯ä»¥çœ‹åˆ°å³ä¾¿æ˜¯å‡½æ•°è¿™æ ·çš„ç±»å‹ä¹Ÿæ˜¯é€šè¿‡æ„é€ æ¥å®šä¹‰çš„:

```haskell
>>> :i (->)
data (->) t1 t2         -- Defined in â€˜GHC.Primâ€™
```

### é€’å½’ç±»å‹

**é€’å½’ç±»å‹**ï¼Œå®šä¹‰ç±»å‹æ—¶ç”¨åˆ°äº†æ­£åœ¨å®šä¹‰çš„è¯¥ç±»å‹æœ¬èº«ã€‚

æ•°å­¦ä¸­çš„è‡ªç„¶åå¯ä»¥æ—¶é€’å½’å®šä¹‰çš„ï¼Œç±»å‹çš„åå­—å®šä¹‰å¯ä»¥å–ä¸ºNatã€‚é¦–å…ˆï¼Œè‡ªç„¶æ•°æ—¶ä»0å¼€å§‹çš„ï¼Œ0å°±æ˜¯é€’å½’å®šä¹‰çš„åŸºæœ¬æƒ…å†µï¼Œè¿™é‡Œå®šä¹‰ä¸ºZeroï¼Œç„¶åå…¶å®ƒæ¯ä¸€ä¸ªè‡ªç„¶æ•°éƒ½æœ‰ä¸€ä¸ªåç»§ï¼ˆsuccessorï¼Œä¹Ÿæœ‰è¯‘ä¸ºè·Ÿéšçš„ï¼‰ï¼Œä¹Ÿå°±æ˜¯æ¯”å½“å‰çš„æ•°å¤§1çš„æ•°ï¼Œè¿™ä¸ªåç»§ä¹Ÿæ˜¯ä¸€ä¸ªè‡ªç„¶æ•°ï¼Œå®šä¹‰ä¸º Succ Natï¼Œä¸€ä¸ªè‡ªç„¶æ•°çš„åç»§ã€‚è¿™å°±æ˜¯è‡ªç„¶æ•°çš„é€’å½’å®šä¹‰ã€‚

```haskell
data Nat = Zero | Succ Nat deriving (Show, Eq, Ord)

natToint :: Nat -> Int
natToint Zero = 0
natToint (Succ n) = 1 + natToint n

int2nat :: Int -> Nat
int2nat 0 = Zero
int2nat n = Succ $ int2nat (n - 1)
-- ä¹Ÿå¯ä»¥ä½¿ç”¨å¦‚ä¸‹æ¨¡å¼åŒ¹é…
-- int2nat (n+1) = Succ $ int2nat n

>>> int2nat 10
Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ Zero)))))))))

>>> natToint $ Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ Zero)))))))))
10

-- å®ç° Nat ç±»å‹çš„åŠ æ³•
-- è¿­ä»£é€’å½’å®ç°
add :: Nat -> Nat -> Nat
add Zero n = n
add (Succ m) n = Succ $ add m n

-- å°¾é€’å½’å®ç°
add :: Nat -> Nat -> Nat
add Zero n = n
add (Succ m) n = add m $ Succ n
```
### æ‚åˆå®šä¹‰ç±»å‹

åœ¨å®šä¹‰ç±»å‹çš„æ—¶å€™ï¼Œå¾ˆå°‘æœ‰æœºä¼šèƒ½çœ‹åˆ°ä¸€ä¸ªç±»å‹æ˜¯é€šè¿‡ç®€å•çš„æ–¹å¼å®šä¹‰çš„ï¼Œå¸¸å¸¸ä¼šç”¨åˆ°å¤šç§å®šä¹‰çš„æ–¹å¼ã€‚

#### æšä¸¾æ„é€ çš„ç±»å‹

```haskell
data Shape = Circle Float | Rect Float Float deriving(Show, Eq)

-- æ·»åŠ è®¿é—®å™¨å‡½æ•°
data Shape = Circle {
                radius :: Float
            } |
            Rect {
                len :: Float,
                width :: Float
            } deriving(Show, Eq)

-- è®¡ç®—é¢ç§¯
area :: Shape -> Float
area (Circle r) = pi * r ^ 2
area (Rect a b) = a * b

data Person = Person {
    name :: String,
    age :: Int,
    sex :: Bool
    }
-- åœ¨æ¨¡å¼åŒ¹é…æ—¶ï¼Œä¸éœ€è¦æŠŠæ‰€æœ‰å±æ€§éƒ½å†™å‡ºæ¥ï¼Œä¸‹é¢çš„ä»£ç å¹¶æ²¡æœ‰åŒ¹é… age
showPerson :: Person -> String
showPerson (Person {name = str, sex = s}) = str ++ show s
```

#### æšä¸¾é€’å½’å®šä¹‰

```haskell
-- æšä¸¾å’Œé€’å½’å®šä¹‰çš„ç±»å‹
data BoolExp = TRUE | FALSE | IF BoolExp BoolExp BoolExp deriving (Show, Eq)

eval :: BoolExp -> Bool
eval TRUE = True
eval FALSE = False
eval (IF con b1 b2) | eval con == True  = eval b1
                    | eval con == False = eval b2
                    

-- ä¸Šé¢çš„é€’å½’çš„ä¼°å€¼è®¡ç®—çš„å®é™…è¿è¡Œè¿‡ç¨‹éœ€è¦ä¸æ–­åœ¨å†…å­˜ä¸Šè¿›è¡Œå †æ ˆæ“ä½œï¼Œå¯ä»¥ç”¨ä¸€ä¸ªåˆ—è¡¨æ¥ä»£æ›¿è¿™ä¸ªè¿‡ç¨‹ï¼š
data BoolExp = TRUE | FALSE | IF BoolExp BoolExp BoolExp deriving (Show, Eq)

eval :: BoolExp -> Bool
eval TRUE = True
eval FALSE = False
eval (IF con b1 b2) | eval con == True  = eval b1
                    | eval con == False = eval b2

eval' :: [BoolExp] -> Bool
eval' [TRUE] = True
eval' [FALSE] = False
eval' ((IF TRUE b1 b2):xs) = eval'(b1:xs)
eval' ((IF FALSE b1 b2):xs) = eval'(b2:xs)
eval' (l@(IF con b1 b2):xs) = eval'(con:l:xs)
eval' (TRUE:(IF con b1 b2):xs) = eval' (b1:xs)
eval' (FALSE:(IF con b1 b2):xs) = eval' (b2:xs)
-- test = IF (IF FALSE FALSE TRUE) (IF FALSE TRUE FALSE) FALSE
```

#### å‚æ•°åŒ–é€’å½’ç±»å‹

é¢„åŠ è½½çš„åº“ä¸­å®šä¹‰äº†ä¸€ä¸ªéå¸¸é‡è¦çš„ç±»å‹ï¼Œå°±æ˜¯åˆ—è¡¨ï¼Œå®ƒå°±æ˜¯ç”¨äº†å‚æ•°åŒ–ä¸é€’å½’çš„æ–¹å¼å®šä¹‰çš„ã€‚

```haskell
>>> :i []
data [] a = [] | a : [a]        -- Defined in â€˜GHC.Typesâ€™

{-
 å®šä¹‰ä¸€ä¸ªåˆ—è¡¨
 åˆ—è¡¨è¦ä¹ˆä¸ºç©ºåˆ—è¡¨ï¼Œå®šä¹‰ä¸ºNilï¼Œé‚£ä¹ˆæ—¶ä¸€ä¸ª a ç±»å‹çš„å…ƒç´ ç»“åˆä¸€ä¸ª a ç±»å‹çš„åˆ—è¡¨ã€‚è¿™é‡Œï¼ŒNil ä¸ºé€’å½’å®šä¹‰çš„åŸºæœ¬æƒ…å†µç›¸å½“äºåˆ—è¡¨å®šä¹‰ä¸­çš„ []ï¼Œè€Œ Cons a (List a)ä¸ºé€’å½’å®šä¹‰ã€‚Cons æ—¶ä¸€ä¸ªæ•°æ®çš„æ„é€ å™¨ï¼Œåœ¨è¿™é‡Œç›¸å½“äº (:) è¿ç®—ç¬¦ã€‚List æ—¶ç±»å‹çš„åå­—ï¼ŒNil ä¸ Cons ä¸ºæ„é€ å™¨çš„å‡½æ•°ã€‚
-}
data List a = Nil | Cons a (List a) deriving (Eq, Show)

-- æ—¢ç„¶å®šä¹‰List å’Œ Haskell ä¸­å®šä¹‰çš„åˆ—è¡¨çš„å½¢å¼æ—¶ä¸€æ ·çš„ä»–ä»¬æ—¶å®šä»·çš„ï¼Œé‚£ä¹ˆä»–ä»¬ä¹‹é—´å¯ä»¥ç›¸äº’è½¬æ¢
myListToList Nil = []
myListToList (Cons x xs) = x : (myListToList xs)

listToMyList [] = Nil
listToMyList(x:xs) = Cons x (listToMyList xs)
```


## ç±»å‹çš„åŒæ„

åœ¨ä¸Šé¢ï¼Œå®šä¹‰çš„åˆ—è¡¨ç±»å‹ä¸ Haskell ä¸­çš„åˆ—è¡¨ç±»å‹åŠŸèƒ½æ˜¯ç›¸åŒçš„ã€‚è¿™é‡Œçš„ç›¸åŒå…¶å®å°±æ˜¯æŒ‡ä¸¤ä¸ªç±»å‹â€ç­‰ä»·â€œï¼Œè¿™ç§ç­‰ä»·ç§°ä¸º**åŒæ„ï¼ˆisomorphismï¼‰**ã€‚å¦‚æœä¸¤ä¸ªç±»å‹ A ä¸ B ä¹‹é—´å¯ä»¥ç›¸äº’è½¬æ¢ï¼Œä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬å¯ä»¥å®šä¹‰å‡ºä¸¤ä¸ªè½¬æ¢å‡½æ•°ï¼Œå¹¶ä¸”è¿™ä¸¤ä¸ªå‡½æ•°å‡ä¸ºä¸€ä¸€å¯¹åº”çš„å‡½æ•°ä¸”äº’ä¸ºåå‡½æ•°ï¼Œåˆ™å¯ç§°ç±»å‹ A ä¸ Bæ˜¯åŒæ„çš„ã€‚

**åŒæ„çš„ç±»å‹**ï¼šå¯¹äºä¸¤ä¸ªç±»å‹ A ä¸ Bï¼Œè‹¥å¯ä»¥å®šä¹‰ f :: A - > B å°† Aæ˜ å°„åˆ° Bï¼Œå¹¶ä¸”å¯ä»¥å®šä¹‰ f çš„åå‡½æ•° g :: B -> A å°† B æ˜ å°„åˆ° A ä¸”æ»¡è¶³ f . g = idÊ™ å’Œ g . f = idğ˜ˆ ã€‚ï¼ˆ **.** ä¸ºå¤åˆå‡½æ•°è¿ç®—ç¬¦ï¼Œ  idğ˜ˆ ä¸ idÊ™ åˆ†åˆ«æ˜¯ A ä¸ B ç±»å‹ä¸Šçš„æ’æŒ‡æ˜ å°„ï¼‰ï¼Œé‚£ä¹ˆè¯´ç±»å‹ A ä¸ ç±»å‹ B ä¸ºåŒæ„çš„  è®°åš Aâ‰ƒB ã€‚

**åŒæ„æ˜ å°„**ï¼šå¯¹äºç±»å‹ A ä¸ Bï¼Œå‡½æ•°  f :: A - > B ä¸ºåŒæ„æ˜ å°„ï¼Œè‹¥å­˜åœ¨ä¸€ä¸ªå‡½æ•°ï¼ˆç§°ä¸ºé€†ï¼ˆinverseï¼‰å‡½æ•°ï¼‰ g :: B -> A æ»¡è¶³ï¼šf . g = idÊ™ ï¼Œ g . f = idğ˜ˆ 

```haskell
                          -- åŒæ„ç±»å‹ç¤ºæ„å›¾
						  | â†   g   â†    |
                    idA â†”ï¸ A               B â†”ï¸ idB
                          | â†’    f   â†’    |                  
```

ä»»æ„ç±»å‹éƒ½ä¸è‡ªå·±åŒæ„ï¼Œå³ Aâ‰ƒA ã€‚**å³ â‰ƒ æ˜¯è‡ªåçš„ã€‚(reflexive)**

å¦‚æœ A ä¸ B åŒæ„ï¼Œé‚£ä¹ˆ B ä¸ A ä¹ŸåŒæ„ï¼Œå³ Aâ‰ƒB   =>  Bâ‰ƒAã€‚**å³ â‰ƒ æ˜¯å¯¹ç§°çš„ã€‚ï¼ˆsynmetricï¼‰**

å¦‚æœ  Aâ‰ƒB  å¹¶ä¸” Bâ‰ƒCï¼Œé‚£ä¹ˆ Aâ‰ƒC ï¼Œå³ Aâ‰ƒB  ^ Bâ‰ƒC  => Aâ‰ƒCã€‚**å³ â‰ƒ æ˜¯ä¼ é€’çš„ã€‚(reflexive)**



List å’Œ Haskell å†…ç½®çš„åˆ—è¡¨[] æ˜¯åŒæ„çš„ï¼Œä¸¤ä¸ªç±»å‹åŒæ„åˆ™è¯´æ˜å®šä¹‰åœ¨ [] ä¸­çš„å‡½æ•°åœ¨ List ä¸­ä¹Ÿå¯ä»¥å®šä¹‰ã€‚

```haskell
listHead :: List a -> a
listHead Nil = undefined
listHead (Cons x xs) = x
```

å¯¹äºæšä¸¾ç±»å‹ï¼Œå¦‚æœæ‰€æšä¸¾çš„å€¼çš„ä¸ªæ•°æ˜¯ç›¸ç­‰çš„ã€‚é‚£ä¹ˆå¯ä»¥å†™ä¸¤ä¸ªå‡½æ•°ç›¸äº’è½¬æ¢å¹¶ä¸”èƒ½å¤Ÿæ»¡è¶³åŒæ„çš„æ¡ä»¶ã€‚

å¯¹äºè¿™ç§æƒ…å†µï¼Œå¯ä»¥**æ€»ç»“å‡ºæ›´ä¸ºä¸€èˆ¬çš„è§„åˆ™ï¼šç»™å®šä¸¤ä¸ªä½¿ç”¨æšä¸¾ç±»å‹ï¼Œè‹¥å®ƒä»¬ä¹‹ä¸­å®šä¹‰çš„å€¼çš„ä¸ªæ•°ç›¸ç­‰ï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ªç±»å‹æ˜¯åŒæ„çš„ã€‚**

```haskell
data ThreeNum = One | Two | Three
data Level  = Low | Middle | High

f:: ThreeNum -> Level
f One = Low
f Two = Middle
f Three = High

g :: Level -> ThreeNum
g Low = One
g Middle = Two
g  High = Three
```
åˆ—è¡¨æ˜¯ä¸€ä¸ªå‚æ•°åŒ–å®šä¹‰ç±»å‹ï¼Œè‹¥ç»™å®šè¿™ä¸ªç±»å‹å‚æ•°ä¸º Unitï¼Œå¹¶ä¸” Unit ç±»å‹ä¸­ä»…å®šä¹‰æœ‰ä¸€ä¸ªå€¼ â€”â€” Unitï¼Œé‚£ä¹ˆå¯ä»¥çœ‹å‡ºï¼Œ List Unit ä¸Nat æ˜¯åŒæ„çš„ã€‚å¹¶ä¸”æˆ‘ä»¬å®šä¹‰çš„ Unit ä¸ Haskell å†…ç½®çš„ () ç±»å‹æ˜¯åŒæ„çš„ï¼Œå³ () â‰ƒ Unit

```haskell
data Unit = Unit deriving (Eq, Show)
data List a = Nil | Cons a (List a) deriving (Eq, Show)
data Nat = Zero | Succ Nat deriving (Eq, Show)

-- data List Unit = Nil | Cons Unit (List List)
-- data Nat = Zero | Succ Nat

-- è½¬æ¢å‡½æ•°
list2Nat Nil = Zero
list2Nat (Cons x xs) = Succ (list2Nat xs)

nat2List Zero = Nil
nat2List (Succ n) = Cons Unit (nat2List n)

-- æ‰€ä»¥ï¼Œå¯ä»¥å¾—åˆ°ç»“è®ºï¼š List Unit â‰ƒ Nat
```


ä¸‹é¢ä»‹ç»ä¸€ä¸‹æ–°ç±»å‹çš„æ„å»ºä¸æ›´ä¸ºä¸€èˆ¬çš„åŒæ„ç±»å‹ã€‚è‹¥ç»™å®šç±»å‹ Aã€Bã€Cï¼Œé‚£ä¹ˆä¸‹åˆ—ç»™äºˆå®ƒä»¬çš„å…ƒç¥–æ˜¾ç„¶ä¹Ÿæ˜¯åŒæ„çš„ï¼š

(A, B) â‰ƒ (B, A)

((A, B), C) â‰ƒ (A, (B, C)) â‰ƒ (A,B,C)

å‡½æ•°ç±»å‹ä¹‹é—´ä¹Ÿå¯ä»¥æ˜¯åŒæ„çš„ï¼Œåªæ˜¯æ­¤æ—¶å¯¹åº”çš„è½¬æ¢å‡½æ•° f ä¸ g å‡ä¸ºé«˜é˜¶å‡½æ•°ã€‚

A -> (B, C) â‰ƒ A -> (C, B)

(A, B) -> C â‰ƒ A -> B -> C ï¼ˆä½¿ç”¨ucrry å’Œ uncurry è½¬æ¢å‡½æ•°ï¼‰

**å…ƒç¥–ç±»å‹**ï¼Œåªæœ‰ä¸€ä¸ªæ„é€ å™¨ï¼Œæ„é€ å™¨å†…å«æœ‰å¤šä¸ªç±»å‹ï¼Œåœ¨ä¹¦é¢è¡¨è¾¾å¼å¸¸å¸¸ç”¨ X æ¥è¡¨ç¤ºï¼Œå¦‚äºŒå…ƒå…ƒç»„å¯ä»¥å®šä¹‰ä¸º data Pair A B = Pair A Bã€‚è®°ä½œ A X Bï¼Œç§°ä½œ **ç§¯ç±»å‹ï¼ˆproduct typeï¼‰**ï¼Œåœ¨é›†åˆä¸­ç§°ä¸ºç¬›å¡å°”ç§¯ï¼ˆCartesian productï¼‰ã€‚Pair A B ç±»å‹ä¸­å€¼çš„ä¸ªæ•°æ˜¯ A ä¸ B ç±»å‹çš„å€¼çš„ä¸ªæ•°ä¹‹ç§¯ã€‚å¯ä»¥ç”¨ |X| ç±»å‹çš„å€¼çš„ä¸ªæ•°ï¼Œé‚£ä¹ˆï¼Œåˆ™æœ‰ï¼Œ |A X B| = |A| X |B|ã€‚

**Eitherç±»å‹**ï¼Œç”±å¤šä¸ªæ„é€ å™¨ï¼ˆæˆ–ç§°å¤šæ¨¡å¼ï¼ˆmulti-patternï¼‰ï¼‰æšä¸¾å®šä¹‰çš„ç±»å‹ï¼Œåˆ™ç”¨ + æ¥è¡¨ç¤ºï¼Œæ¯”å¦‚ data Either A B = Left A | Right Bï¼Œè®°ä½œ A + Bï¼Œç§°ä½œ**å’Œç±»å‹ï¼ˆsum typeï¼‰**ï¼Œä»é›†åˆçš„è§’åº¦å¯ä»¥ç†è§£ä¸ºä¸ç›¸äº¤å¹¶é›†ï¼Œå³ï¼Œåœ¨ç»“åˆä¸¤ä¸ªç±»å‹æ—¶ï¼Œå³ä¾¿å®ƒä»¬æœ‰é‡åˆçš„å…ƒç´ ï¼Œä½† Left ä¸ Right æ„é€ å™¨å°†ä½œä¸ºæ ‡è®°å¯¹å®ƒä»¬åŠ ä»¥åŒºåˆ†ã€‚å¦‚ Either Bool Bool ç±»å‹ä¸­æœ‰ Left Trueã€Left Falseã€Right Trueã€Right False è¿™4ä¸ªå€¼ï¼Œåº”è¯¥æ³¨æ„åˆ° Left True å’Œ Right True æ˜¯ä¸åŒçš„å€¼ï¼Œè™½ç„¶å®ƒä»¬æ¥è‡ªäºåŒä¸€ç§ç±»å‹ã€‚æ˜¾ç„¶è¿™ä¸ªç±»å‹å€¼çš„ä¸ªæ•°æ˜¯ A ä¸ B ç±»å‹å€¼çš„ä¸ªæ•°ä¹‹å’Œï¼Œé‚£ä¹ˆï¼Œåˆ™æœ‰ |A + B| = |A| + |B|.

**å‡½æ•°ç±»å‹**ï¼Œå¦‚æœæ˜¯ data Fun = Fun (A -> B) è¿™æ ·çš„å‡½æ•°ç±»å‹ï¼Œè®°ä½œï¼š Bá´¬ï¼Œå³è¿™æ ·çš„å‡½æ•°æœ‰ |B|á´¬| = |Bá´¬|ä¸ªã€‚

åƒ**å¸ƒå°”ç±»å‹**è¿™æ ·ä»¥å…·ä½“å€¼æˆ–è€…ç§°ä¸º**é›¶å…ƒæ„é€ å™¨**çš„ **â€œå’Œâ€ ç±»å‹æœ‰æ—¶ç§°ä¸ºç´¯è®¡ç±»å‹ï¼ˆcountingï¼‰**ï¼Œå¦‚å¸ƒå°”ç±»å‹å¯ä»¥å†™ä¸º 1 + 1ï¼Œç¬¬ä¸€ä¸ª 1 è¡¨ç¤º Falseï¼Œ ç¬¬äºŒä¸ª 1 è¡¨ç¤º Trueï¼Œå¯ä»¥çœ‹åˆ°ä»–ä¸ Either () () åŒæ„ã€‚

```haskell
bool2EitherUnit :: Bool -> Either () ()
bool2EitherUnit False = Left ()
bool2EitherUnit True = Right ()

eitherUnit2Bool :: Either () () -> Bool
eitherUnit2Bool (Left ()) = False
eitherUnit2Bool (Right ()) = True
```

å¯¹äºè‡ªç„¶æ•°çš„è‡ªå®š data Nat = Zero | Succ Nat ï¼Œåˆ™å†™ä¸º Nat = 1 + Natï¼Œå¯ä»¥çœ‹åœ¨å®šä¹‰ä¸­ä½¿ç”¨åˆ°äº† Nat æœ¬èº«ï¼Œå› ä¸ºè¿™æ˜¯ä¸€ä¸ªé€’å½’ç±»å‹ã€‚

**è¿™æ ·ç”± () ç±»å‹é€šè¿‡ å’Œç±»å‹ã€ç§¯ç±»å‹è¿˜æœ‰å‡½æ•°ç±»å‹ç­‰ç­‰æ–¹å¼ç»„åˆå®šä¹‰å‡ºæ¥çš„ç±»å‹ç§°ä¸º ä»£æ•°æ•°æ®ç±»å‹ï¼ˆAlgebraic Data Typeï¼Œç®€å†™ä¸º ADTï¼‰ã€‚**

`data T = Con a1 a2 a3 a4 ... an` ï¼Œè¿™é‡Œä½¿ç”¨çš„å¤šä¸ªå‚æ•°ä¸ä½¿ç”¨ä¸€ä¸ªå…ƒç»„å®šä¹‰æ—¶ç­‰ä»·çš„ï¼Œ T çš„ç±»å‹å¯è®°ä½œ a1 Ã— a2 Ã— a3 Ã— a4 Ã— ... anï¼Œè¿™ä¸ªç±»å‹æ˜¾ç„¶ä¸ n å…ƒå…ƒç»„æ˜¯åŒæ„çš„ã€‚ 

`data T = A a b c .. | B d e f .. | C g h i ..| ...`ï¼Œ è¿™é‡Œçš„ T ç±»å‹å¯ä»¥è®°ä½œ (a Ã— b Ã— c ...) +  (d Ã— e Ã— f â€¦) +  (g Ã— h Ã— i â€¦) + â€¦  ã€‚è¿™æ ·çš„ç±»å‹ä¹Ÿç§°ä¸º**ä¸€èˆ¬åŒ–çš„ç»“æ„ç±»å‹**ã€‚



ä¹‹å‰ä»‹ç»çš„å‡ ä¸ªåŒæ„å…³ç³»å¯ä»¥è®°ä½œï¼š

A Ã— B â‰ƒ B Ã— A

(A Ã— B) Ã— C â‰ƒ A Ã— (B Ã— C)

(B Ã— C)á´¬ â‰ƒ (C Ã— B)á´¬

C(á´¬â¨¯á´®) â‰ƒ (Cá´®)á´¬  ï¼ˆä½¿ç”¨ucrry å’Œ uncurry è½¬æ¢å‡½æ•°ï¼‰

è¿˜ç¼ºå°‘è¯æ˜ TODO



æ­¤å¤–ï¼Œå¯¹äºï¼š A Ã— (B Ã— C) â‰ƒ A Ã— B + A Ã— C

(A, Either B C) å’Œ Either (A, B) (A, C) æ˜¾ç„¶æ˜¯åŒæ„çš„ã€‚

(A, Either B C)        				 ä¸º A * (B + C)

Either (A, B) (A, C)  ä¸º A * B +  A * C ç­‰äº A * (B + C)

```haskell
f :: (a, Either b c) -> Either (a, b) (a, c)
f (a, Left b) = Left (a, b)
f(a, Right c) = Right (a, c)

g ::  Either (a, b) (a, c) -> (a, Either b c)
g (Left (a, b)) = (a, Left b)
g (Right (a, c)) = (a, Right c)
```
è¿™æ ·ï¼Œä½¿ç”¨ **æ¨¡å¼åŒ¹é…** æˆ–è€… **case** æ¥å®šä¹‰åŸºäºæŸä¸€ç±»å‹çš„å‡½æ•°å¼ï¼Œæ¯ä¸€æ¡åŒ¹é…å®é™…ä¸ŠåŒ¹é…çš„æ˜¯è¯¥**å’Œç±»å‹**çš„æŸä¸€ä¸ªå˜ä½“ï¼Œå³æŸä¸€ä¸ªæ„é€ å™¨ä¸è¯¥æ„é€ å™¨çš„å‚æ•°ï¼Œè¿™ä¸ªå‚æ•°å¯èƒ½æ˜¯ä¸€ä¸ª **ç§¯** **æˆ–è€…ä¸€ä¸ªå‚æ•°**ã€‚è€Œéœ€è¦å¯¹ä¸€ä¸ªå‚æ•°è¿›è¡Œå¤šä¸ªæ¨¡å¼åŒ¹é…åˆ™æ˜¯å› ä¸ºè¯¥ç±»å‹æ˜¯é€šè¿‡å¤šä¸ªæ•°æ®æ„é€ å™¨çš„å’Œå®šä¹‰çš„ï¼Œä¹Ÿå°±æ˜¯å› ä¸ºè¿™ä¸ªç±»å‹æœ‰å¤šä¸ªå˜ä½“ï¼Œå¤šç§æ¨¡å¼ã€‚

Either çš„å®šä¹‰å’Œæ¨¡å¼åŒ¹é…å¦‚ä¸‹ï¼š

```haskell
data Either a b = Left a | Right b
f (Left a)  = ...
f (Right b) = ...
```

å¯ä»¥çœ‹åˆ° Either ç±»å‹æœ‰ä¸¤ä¸ªå˜ä½“æˆ–è€…è¯´ä¸¤ç§æ¨¡å¼ Left ä¸Rightï¼Œæ‰€ä»¥æœ‰ä¸¤æ¡åŒ¹é…ï¼Œè€Œæ¯æ¡åŒ¹é…éƒ½ä¼šå¾—åˆ°æ„é€ å™¨ä¸­çš„å‚æ•°ã€‚åŒæ—¶ï¼Œè¯»è€…ä¹Ÿåº”è¯¥æ„è¯†åˆ° Non-exhaustive patterns å¼‚å¸¸çš„åŸå› äº†ï¼Œå³åœ¨å®šä¹‰å‡½æ•°æ—¶ï¼Œæ²¡æœ‰æŠŠæ‰€æœ‰çš„æ•°æ®å½¢å¼éƒ½è€ƒè™‘è¿›æ¥ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæœ‰ä¸€äº›å½¢å¼åœ¨æˆ‘ä»¬çš„å‡½æ•°ç§æ²¡æœ‰è¢«å®šä¹‰ï¼Œä½†æ˜¯è°ƒç”¨å‡½æ•°æ—¶å‡ºç°äº†è¿™ç§å½¢å¼æ²¡æœ‰åŒ¹é…ã€‚**åœ¨ç¼–è¯‘çš„è¿‡ç¨‹ä¸­ï¼ŒGHC ä¼šå¯¹è¿™äº›é—æ¼ç»™å‡ºä¸€äº›è­¦å‘Šï¼Œå³ä¾¿å®šä¹‰æ—¶ç¡®å®šä¸ä¼šå‡ºç°è¿™ç§å½¢å¼ï¼Œä¹Ÿæœ€å¥½é€šè¿‡ error æˆ–è€…å…¶å®ƒæ–¹å¼æ¥å®šä¹‰ä¸ä¸Šè¿™ä¸ªç¼ºå£ã€‚**

```haskell
-- ä½¿ç”¨å€¼æ„é€ å™¨ :  åšæ¨¡å¼åŒ¹é…
get4 (_:_:_:x:_) = x
get4 _ = error "error param"

-- å¯ä»¥ä½¿ç”¨ NPlusKPatterns è¯­è¨€æ‰©å±• (n + 1)æ–¹å¼çš„æ¨¡å¼åŒ¹é…ï¼Œä¸æ¨èä½¿ç”¨
{-# LANGUAGE  NPlusKPatterns #-}
data Nat = Zero | Succ Nat deriving (Show, Eq, Ord)
int2nat :: Int -> Nat
int2nat 0 = Zero
-- int2nat n = Succ $ int2nat (n - 1)
int2nat (n + 1) = Succ $ int2nat n 
```
## å¤šæ¡ä»¶åˆ†æ”¯ã€æ¨¡å¼åŒ¹é…å®ˆå«ã€è§‚å¯Ÿæ¨¡å¼è¡¨è¾¾å¼ä¸æ¨¡å¼çš„åˆ«å

æœ¬èŠ‚çš„å†…å®¹ä¸»è¦æ˜¯è§£å†³äº†ä¸€äº›æˆ‘ä»¬åœ¨ä½¿ç”¨ Haskell ç¼–ç¨‹ä¸­é‡åˆ°çš„ç—›ç‚¹ï¼ŒåŸºæœ¬å…¨å±äº è¯­æ³•ç³–ã€‚

### å¤šåˆ†æ”¯æ¡ä»¶è¡¨è¾¾å¼

é¦–å…ˆåœ¨æ–‡ä»¶é¦–å¤„å£°æ˜ **MultiWayIf** ç¼–è¯‘å™¨æ‰©å±•ï¼Œç„¶åå†å®šä¹‰å‡½æ•°ã€‚

```haskell
{-# LANGUAGE MultiWayIf  #-}

-- è¿™é‡Œçš„è¡¨è¾¾å¼ä¸ ç¼©è¿› æœ‰å…³
test score = if | score > 60 -> if | score == 100 -> "A"
                                   | score >= 90  -> "B"
                                   | score >= 70  -> "C"
                                   | otherwise    -> "D"
                | score > 50 -> "E"
                | otherwise  -> "F"

-- å¦‚æœæƒ³è½¬æˆç¼©è¿›æ— å…³çš„ä»£ç å¯ä»¥ä½¿ç”¨èŠ±æ‹¬å· {} æ¥æŒ‡æ˜æ¯ä¸ªåˆ†æ”¯æ‰€åœ¨çš„èŒƒå›´
{-# LANGUAGE MultiWayIf  #-}
test score = if {| score > 60 ->
                    if {| score == 100 -> "A" | score >= 90  -> "B" | score >= 70  -> "C" | otherwise -> "D"}
       | score > 50 -> "E"
       | otherwise  -> "F"}
```
### æ¨¡å¼åŒ¹é…å®ˆå«è¡¨è¾¾å¼

é¦–å…ˆåœ¨æ–‡ä»¶é¦–å¤„å£°æ˜ **PatternGuards** ç¼–è¯‘å™¨æ‰©å±•ï¼Œç„¶åå†å®šä¹‰å‡½æ•°ã€‚

```haskell
{-# LANGUAGE PatternGuards  #-}

-- Triangle ä¸‰è§’å½¢
data Shape = Triangle Int Int Int | Circle Int

isValidShape :: Shape -> Bool
isValidShape s | Circle r       <- s, r > 0 = True
isValidShape s | Triangle a b c <- s, c > 0 && c > 0 && c > 0 &&
                                      a + b > c && a + c > b && b + c > a
                                      = True
isValidShape _ = False

-- å¦ä¸€ç§å†™æ³•
isValidShape :: Shape -> Bool
isValidShape (Circle r)       | r > 0 = True
isValidShape (Triangle a b c) | c > 0 && c > 0 && c > 0 && a + b > c && a + c > b && b + c > a = True
isValidShape _ = False
```

æ¨¡å¼åŒ¹é…å®ˆå«è¡¨è¾¾å¼è¿˜å¯ä»¥åŒ¹é…å¤šç§ç±»å‹

```haskell
-- {-# LANGUAGE PatternGuards  #-}

-- Triangle ä¸‰è§’å½¢
data Shape = Triangle Int Int Int | Circle Int

isValidShape :: Maybe Bool -> Shape -> Bool
isValidShape m s | Just x <- m, Circle r       <- s, r > 0 = x && True
isValidShape m s | Just x <- m, Triangle a b c <- s, c > 0 && c > 0 && c > 0 &&
                                      a + b > c && a + c > b && b + c > a
                                      = x && True
isValidShape _ _ = False
```

### è§‚å¯Ÿæ¨¡å¼è¡¨è¾¾å¼

é¦–å…ˆåœ¨æ–‡ä»¶é¦–å¤„å£°æ˜ **ViewPatterns** ç¼–è¯‘å™¨æ‰©å±•ï¼Œç„¶åå†å®šä¹‰å‡½æ•°ã€‚

```haskell
{-# LANGUAGE ViewPatterns  #-}

import Data.Sequence

one2ten :: Seq Int
one2ten = fromList [1..10]

-- ä½¿ç”¨ case çš„ æƒ…å†µæ¨¡å¼è¡¨è¾¾å¼
match :: Seq Int -> Seq Int -> (Int, Seq Int)
match s1 s2 = case viewl s1 of
                   EmptyL -> case viewr s2 of
                                  EmptyR -> (0, s2)
                                  xs :> x -> (x, xs)
                   a :< as -> case viewr s2 of
                                  EmptyR -> (a, as)
                                  xs :> x -> (a + x, xs >< as)

-- ä½¿ç”¨ è§‚å¯Ÿæ¨¡å¼è¡¨è¾¾å¼
-- è§‚å¯Ÿæ¨¡å¼åŒ¹é…ä¸­ -> å·¦ä¾§çš„æ˜¯è§‚å¯Ÿå‡½æ•°ï¼Œå®ƒæ˜¯éœ€è¦ä¸€ä¸ªå‚æ•°å¾—åˆ°ç»“æœï¼Œéœ€è¦æŠŠæ¨¡å¼å†™åœ¨è‚©å¤´çš„å³ä¾§
match' :: Seq Int -> Seq Int -> (Int, Seq Int)
match' (viewl -> EmptyL) s2@(viewr -> EmptyR) = (0, s2)
match' (viewl -> EmptyL) (viewr -> xs :> x)   = (x, xs)
match' (viewl -> a :< as) (viewr -> EmptyR)   = (a, as)
match' (viewl -> a :< as) (viewr -> xs :> x)  = (a + x, xs >< as)

>>> match empty empty 
(0,fromList [])

>>> match empty one2ten  
(10,fromList [1,2,3,4,5,6,7,8,9])

>>> match one2ten empty   
(1,fromList [2,3,4,5,6,7,8,9,10])

>>> match one2ten (fromList [100..110])
(111,fromList [100,101,102,103,104,105,106,107,108,109,2,3,4,5,6,7,8,9,10])
```
### æ¨¡å¼çš„åˆ«å

é¦–å…ˆåœ¨æ–‡ä»¶é¦–å¤„å£°æ˜ **PatternSynonyms** ç¼–è¯‘å™¨æ‰©å±•ï¼Œç„¶åå†å®šä¹‰å‡½æ•°ã€‚

```haskell
{-# LANGUAGE PatternSynonyms #-}

data Exp = Val Int | Exp String [Exp]
pattern Add t1 t2 = Exp "+" [t1, t2]
pattern Sub t1 t2 = Exp "-" [t1, t2]

eval (Val n) = n
eval (Add t1 t2) = eval t1 + eval t2
eval (Sub t1 t2) = eval t1 - eval t2

>>> eval (Add (Val 100) (Val 200))
300
>>> eval (Sub (Val 100) (Val 200))
-100
```

å¦‚æœå¼€å¯äº† **PatternSynonyms** å°±æ— æ³•å®šä¹‰åä¸º pattern çš„å‡½æ•°äº†ã€‚