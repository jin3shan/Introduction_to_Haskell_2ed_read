Haskell ä¸»è¦ä½¿ç”¨ data ä¸Ž newtype å…³é”®å­—æ¥å®šä¹‰æ–°çš„ç±»åž‹ã€‚

å®šä¹‰æ–°çš„ç±»åž‹åŽï¼Œå¯èƒ½ä¼šå‘çŽ°è¿™äº›ç±»åž‹ä¸Žä¹‹å‰ç”¨è¿‡çš„ç±»åž‹æ˜¯ç­‰ä»·çš„ï¼Œè¿™ç§ç­‰ä»·ç§°ä¸ºåŒæž„ï¼ˆisomorphismï¼‰ã€‚

## æ•°æ®ç±»åž‹çš„å®šä¹‰

### æžšä¸¾ç±»åž‹

å¸ƒå°”ç±»åž‹åœ¨ Haskell ä¸­å°±æ˜¯æžšä¸¾å®šä¹‰çš„ï¼Œè¿™ä¸ªç±»åž‹é‡Œåªæœ‰ä¸¤ä¸ªå€¼ï¼Œå³ True ä¸Ž Falseã€‚

åœ¨ Prelude ä¸­å®ƒæ˜¯è¿™æ ·å®šä¹‰çš„ï¼š

```haskell
data Bool = False | True 
```

**data** æ˜¯å®šä¹‰æ–°ç±»åž‹çš„å…³é”®å­—ï¼ŒåŽè¾¹è·Ÿæƒ³è¦å®šä¹‰çš„ç±»åž‹åç§°ï¼Œç±»åž‹åç§°é¦–å­—æ¯è¦å¤§å†™ã€‚ç„¶åŽ**å®šä¹‰å¸ƒå°”ç±»åž‹çš„å€¼ï¼Œå³ True ä¸Ž False**ã€‚

å¸ƒå°”ç±»åž‹æ˜¯ä¸€ä¸ªéžå¸¸ç®€å•çš„ç±»åž‹ï¼Œè¿™ä¸ªç±»åž‹åªå¯èƒ½æœ‰ä¸¤ä¸ªå€¼ï¼Œä¹Ÿå¯ä»¥ç§°ä¸ºä¸¤ç§å½¢å¼ï¼ŒTrue æˆ–è€… Falseã€‚è¿™é‡Œåªéœ€è¦å°†å®ƒä»¬ä¸€æ¬¡å†™å‡ºï¼Œç”¨ "|"åˆ†å¼€å³å¯ã€‚è¿™ç§å®šä¹‰çš„æ–¹å¼å¯ä»¥è¢«ç§°ä¸ºæžšä¸¾å®šä¹‰ï¼Œå³å®šä¹‰çš„å€¼èƒ½å¤Ÿä»¥ä¸€å®šçš„é¡ºåºä¸€ä¸€åœ°æžšä¸¾å‡ºæ¥ã€‚ä½¿ç”¨æ¨¡å¼åŒ¹é…å®šä¹‰å‡½æ•°æ—¶å°±æ˜¯åŒ¹é… "|"ä¹‹é—´ä¸åŒçš„å®šä¹‰æ¨¡å¼ã€‚

å®šä¹‰â€œæ˜ŸæœŸâ€ç±»åž‹

```haskell
-- è¿™é‡Œå¯ä»¥å…ˆä½¿ç”¨ deriving å…³é”®å­—æ¥è®©è¿™ä¸ªç±»åž‹è‡ªåŠ¨å®žçŽ°ä¸€äº›ç±»åž‹ç±»

data Day = Mon | Tue | Wed | Thu | Fri | Sat | Sun
 deriving (Show, Eq, Ord, Enum)
 
 -- å®žçŽ°äº†Showç±»åž‹ç±»
 >>> Mon
Mon

-- å®žçŽ°äº†Eqç±»åž‹ç±»
>>> Mon == Mon
True

-- å®žçŽ°äº†Ordç±»åž‹ç±»
-- ç”±äºŽæœ‰åºç±»åž‹ç±»Ordæ˜¯åŸºäºŽç›¸ç­‰ç±»åž‹ç±» Eq çš„ï¼Œå› æ­¤ä¸€å®šè¦å®žçŽ°ç›¸ç­‰ç±»åž‹ç±» Eq åŽæ‰èƒ½å®žçŽ°æœ‰åºç±»åž‹ç±» Ord 
>>> Mon < Sun
True

-- å®žçŽ°äº†Enum ç±»åž‹ç±»
>>> [Mon .. Sun]
[Mon,Tue,Wed,Thu,Fri,Sat,Sun]

-- é€šè¿‡æ¨¡å¼åŒ¹é…å®žçŽ° tomorrow å‡½æ•°
-- è¿™ä¸ª tomorrow å‡½æ•°çš„å®žçŽ°æ¯”è¾ƒéº»çƒ¦
tomorrow :: Day -> Day
tomorrow Mon = Tue
tomorrow Tue = Wed
tomorrow Wed = Thu
tomorrow Thu =Fri
tomorrow Fri =Sat
tomorrow Sat =Sun
tomorrow Sun = Mon

{--
ç”±äºŽç±»åž‹ Day å®žçŽ°äº†æžšä¸¾ç±»åž‹ç±» Enum åŽï¼Œæœ‰å¾ˆå¤šå‡½æ•°å¯ä»¥ç«‹å³ä½¿ç”¨ï¼Œå¦‚ succã€ pred åŠå…¶ä»–çš„å‡½æ•°ï¼Œè¿™é‡Œç®€å•ä»‹ç»  succ ï¼ˆsuccessorçš„ç®€å†™ï¼‰å‡½æ•°ä¸Ž pred (predecessor çš„ç®€å†™)å‡½æ•°ã€‚succ å‡½æ•°ä¼šè¿”å›žå‚æ•°çš„ä¸‹ä¸€ä¸ªæžšä¸¾ç±»åž‹çš„å€¼ï¼Œè€Œ pred ä¼šè¿”å›žç»™å®šå‚æ•°çš„å‰ä¸€ä¸ªæžšä¸¾ç±»åž‹çš„å€¼ã€‚
--}
-- å¦‚æžœç»™å®šçš„å‚æ•°å·²ç»ä¸ºè¾¹ç•Œå€¼ï¼Œåˆ™ä¼šå‡ºçŽ°å¼‚å¸¸
tomorrow' :: Day -> Day
tomorrow' Sun = Mon
tomorrow' day = succ day
```

é™¤äº†ä»¥ä¸Šçš„ 4 ä¸ªæ¯”è¾ƒå¸¸ç”¨çš„ç±»åž‹ç±»ï¼Œè¿˜æœ‰å¯è¯»ç±»åž‹ç±» Readï¼Œå³å¯ä»¥ä½¿ç”¨ read å‡½æ•°æ¥å°†ä¸€ä¸ªå­—ç¬¦ä¸²è¯»æˆ Day çš„ç±»åž‹çš„æ•°æ®ã€‚

```haskell
data Day = Mon | Tue | Wed | Thu | Fri | Sat | Sun
 deriving (Show, Read)
 
 >>> read "Mon" :: Day 
Mon
```

å€¼å¾—ä¸€æçš„æ˜¯ï¼Œå¦‚æžœä¸€ä¸ªæ•°æ®ç±»åž‹ a æ˜¯å¯è¯»çš„ï¼Œé‚£ä¹ˆä¾èµ–äºŽ a çš„ç±»åž‹ b ä¹Ÿæ˜¯å¯è¯»çš„ã€‚æ¯”å¦‚ï¼Œæ•°æ® Day æ˜¯å¯è¯»çš„ï¼Œä»¥æ¥äºŽ Day ç±»åž‹çš„åˆ—è¡¨ [Day] ä¹Ÿæ˜¯å¯è¯»çš„ã€‚

```haskell
>>> read "[Mon, Tue]" :: [Day]
[Mon,Tue]
```

### æž„é€ ç±»åž‹

```haskell
-- æž„é€  Book ç±»åž‹
type Name = String
type Author = String
type ISBN = String
type Price = Float

data Book = Book Name Author ISBN Price deriving(Show, Eq)
```

data Book ä¸­çš„ Bookæ˜¯ç±»åž‹çš„åç§°ï¼Œä¹Ÿç§°ä¸º**ç±»åž‹æž„é€ å™¨**ï¼ˆ*ç±»åž‹æž„é€ å™¨å¯ä»¥æœ‰ç±»åž‹å‚æ•°ï¼Œå³å‚æ•°åŒ–ç±»åž‹*ï¼‰ã€‚

Book Name Author ISBNä¸­çš„ Book ç§°ä¸º**æ•°æ®æž„é€ å™¨**ï¼ˆdata constructorï¼‰ã€‚

è™½ç„¶åœ¨å¾ˆå¤šç±»åž‹çš„å®šä¹‰ä¸­ç±»åž‹çš„åç§°ä¸Žæ•°æ®æž„é€ å™¨çš„åç§°æ˜¯ç›¸åŒçš„ï¼Œä½†ç»ä¸èƒ½æ··æ·†ç±»åž‹æž„é€ å™¨å’Œæ•°æ®æž„é€ å™¨ï¼Œã€‚

å…¶å®žï¼Œæ•°æ®æž„é€ å™¨æœ¬èº«æ˜¯ä¸€ç§ç‰¹æ®Šçš„å‡½æ•°ï¼Œä¸è¿‡é¦–å­—æ¯ä¼šå¤§å†™ã€‚

```haskell
-- é€šè¿‡æŸ¥çœ‹ Book çš„ç±»åž‹å¯ä»¥çŸ¥é“ï¼Œæž„é€ å™¨æœ¬è´¨ä¸Šæ˜¯ä»¥é‚£äº›å‡½æ•°ä½œä¸ºè¾“å…¥ï¼Œè¿”å›žä¸€ä¸ª Book ç±»åž‹çš„æ•°æ®çš„å‡½æ•°
>>> :t Book
Book :: Name -> Author -> ISBN -> Price -> Book

--è®¿é—®ç±»åž‹ä¸­çš„å‚æ•°
name   (Book n _ _ _) = n
author (Book _ a _ _) = a
isbn   (Book _ _ i _) = i
price  (Book n _ _ p) = p

>>> name $ Book  "Haskell" "Mark" "45678" 10
"Haskell"
```

Haskell æä¾›äº†å¦ä¸€ç§å®šä¹‰çš„è¯­æ³•ï¼Œè¿™ä¸ªè¯­æ³•ä½¿å¾—è®¿é—®å™¨å‡½æ•°è½½è¿™ä¸ªç±»åž‹å®šä¹‰çš„åŒæ—¶ä¹Ÿè¢«å®šä¹‰å‡ºæ¥äº†ã€‚

```haskell
data Book = Book {
         name :: Name,
         author :: Author ,
         isbn :: ISBN,
         price :: Price
       } deriving(Show, Eq)
```

è®¿é—®å™¨çš„åç§°å¦‚ nameã€author ç­‰ï¼Œè¢«ç§°ä¸º**å­—æ®µå**æˆ–è€…**è®°å½•(record)**ã€‚

ç”±äºŽæ˜¯è®¿é—®Bookçš„å‡½æ•°ï¼Œæ‰€ä»¥è¿™äº›å‡½æ•°éƒ½éœ€è¦ä¸€ä¸ªBook ç±»åž‹çš„å€¼ä½œä¸ºå‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°ã€‚

```haskell
>>> :t name
name :: Book -> Name

>>> :t author
author :: Book -> Author
```



```haskell
-- ä¹¦åº—ä¸­çš„ä¸€äº›ä¹¦è¦æ¶¨ä»·ï¼Œä¹¦åº—éœ€è¦åˆ†åˆ«è®°å½•åŽŸä»·å’Œæ¶¨ä»·åŽä¹¦çš„ä¿¡æ¯
incrisePrice :: ([Book], [Book]) -> Book -> Float -> ([Book], [Book])
incrisePrice (b1, b2) b pri = ((b: b1), (Book (name b) (author b) (isbn b) (price b + pri)) : b2)

>>> incrisePrice ([(Book  "Haskell" "Mark" "45678" 10)],[]) (Book  "Scheme" "Jim" "654" 100) 150

([Book {name = "Scheme", author = "Jim", isbn = "654", price = 100.0},Book {name = "Haskell", author = "Mark", isbn = "45678", price = 10.0}],[Book {name = "Scheme", author = "Jim", isbn = "654", price = 250.0}])

-- é‡æž„ç‰ˆæœ¬1
incrisePrice (b1, b2) (Book nm ath isbn prc) pri = ((Book nm ath isbn prc):b1, (Book nm ath isbn (prc+pri)):b2)

-- é‡æž„ç‰ˆæœ¬2ï¼Œä½¿ç”¨@ç¬¦å·æ¥ç”¨ä¸€ä¸ªåå­—æ¥æŒ‡ä»£è¿™ä¸ªæž„é€ çš„æ•°æ®
incrisePrice (b1, b2) b@(Book nm ath isbn prc) pri = (b:b1, (Book nm ath isbn (prc+pri)):b2)

-- é‡æž„ç‰ˆæœ¬3
incrisePrice (b1, b2) b pri = (b:b1, (b{price=pri}):b2)
```
ä¸Šé¢è®¨è®ºçš„ Book æ•°æ®æž„é€ å™¨æ˜¯éœ€è¦ä¸€äº›å…¶å®ƒå‚æ•°å¡«å……çš„ï¼Œè€Œæœ‰çš„æ—¶å€™ï¼Œæž„é€ å™¨ä¸Žå€¼å…¶å®žå¹¶æ²¡æœ‰æ˜¾è‘—çš„åŒºåˆ«ï¼Œæ¯”å¦‚ï¼Œå¯ä»¥è®¤ä¸º True ä¸Ž False å°±æ˜¯å¸ƒå°”ç±»åž‹çš„æž„é€ å™¨ï¼Œå®ƒä»¬ä¸éœ€è¦å‚æ•°ç§°ä¸º**é›¶å…ƒæ•°æ®æž„é€ å™¨**ï¼ˆ**nullary data constructor**ï¼‰ã€‚

### å‚æ•°åŒ–ç±»åž‹

**å‚æ•°åŒ–ç±»åž‹æ˜¯éœ€è¦ç±»åž‹å‚æ•°çš„ç±»åž‹**ã€‚å‚æ•°åŒ–ç±»åž‹çš„å®šä¹‰ä¸­çš„ç±»åž‹åç§°åŽå¯ä»¥åŠ ä¸€ä¸ªä»»æ„çš„ç±»åž‹å‚æ•°ä»¥ä¾›è¿™ä¸ªç±»åž‹çš„æ•°æ®æž„é€ å™¨ä½¿ç”¨ï¼Œè¿™æ ·çš„æž„é€ å™¨å¯ä»¥æš‚æ—¶ç®€å•ç†è§£ä¸ºä¸€ä¸ªå®¹å™¨ï¼Œä¸Žæž„é€ ç±»åž‹ä¸åŒï¼Œè¿™é‡Œçš„å‚æ•°å¯ä»¥æ˜¯ä»»ä½•çš„å¤šæ€ç±»åž‹ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªç¡®å®šçš„ç±»åž‹ã€‚

```haskell
data Maybe a = Nothing | Just a
```

Maybeå¯ä»¥ç†è§£ä¸ºä¸€ç§å®¹å™¨ç±»åž‹ï¼Œé‡Œé¢å¯ä»¥æ”¾ä¸€äº›ä¸œè¥¿ã€‚Just å†…çš„ç±»åž‹ a å¯ä»¥æ˜¯ä»»æ„çš„ç±»åž‹ï¼ŒFloatã€Doubleã€å…ƒç»„ ç”šè‡³æ˜¯å‡½æ•°ç±»åž‹ã€‚è¿™é‡Œ Just å°±æ˜¯ä¸€ä¸ªæž„é€ å™¨ï¼Œè¿™ä¸ªæž„é€ å™¨æ˜¯ä¸€ä¸ªå •èƒŽç±»åž‹çš„å‡½æ•°ï¼Œå®ƒçš„ç±»åž‹æ˜¯ a -> Maybe a

```haskell
>>> :i Maybe
data Maybe a = Nothing | Just a         -- Defined in â€˜GHC.Baseâ€™
instance Eq a => Eq (Maybe a) -- Defined in â€˜GHC.Baseâ€™
instance Monad Maybe -- Defined in â€˜GHC.Baseâ€™
instance Functor Maybe -- Defined in â€˜GHC.Baseâ€™
instance Ord a => Ord (Maybe a) -- Defined in â€˜GHC.Baseâ€™
instance Read a => Read (Maybe a) -- Defined in â€˜GHC.Readâ€™
instance Show a => Show (Maybe a) -- Defined in â€˜GHC.Showâ€™
instance Applicative Maybe -- Defined in â€˜GHC.Baseâ€™
instance Foldable Maybe -- Defined in â€˜Data.Foldableâ€™
instance Traversable Maybe -- Defined in â€˜Data.Traversableâ€™
instance Monoid a => Monoid (Maybe a) -- Defined in â€˜GHC.Baseâ€™
```

Maybeç±»åž‹å®žçŽ°äº† Eqã€Ordã€Readã€Show ç±»åž‹ç±»ã€‚

å¦‚æžœ a å¯ä»¥æ¯”è¾ƒç›¸ç­‰ï¼Œé‚£ä¹ˆ Maybe a ä¹Ÿå¯ä»¥æ¯”è¾ƒç›¸ç­‰ã€‚

```haskell
>>> Nothing < Just 3
True

{-
è¿™é‡Œé”™è¯¯çš„æ„æ€æ˜¯ï¼Œå‡½æ•°çš„ç±»åž‹æ²¡æœ‰å®žçŽ°æœ‰åºç±»ï¼Œæ‰€ä»¥ä¸èƒ½ä½¿ç”¨ < è¿›è¡Œæ¯”è¾ƒï¼Œåœ¨ä»»ä½•è¯­è¨€ä¸­å‡½æ•°éƒ½æ˜¯æ— æ³•ç›´æŽ¥æ¯”è¾ƒç›¸ç­‰è¿˜æœ‰å¤§å°çš„ã€‚
å¦‚æžœæœ‰è¯­è¨€æ¯”è¾ƒäº†å‡½æ•°çš„ç›¸ç­‰ï¼Œå®ƒæ¯”è¾ƒçš„ä¸€åŠæ˜¯å‡½æ•°çš„æ‰€åœ¨åœ°å€æˆ–è€…ç¼–è¯‘æˆçš„æŒ‡ä»¤ï¼Œå³æ— æ³•æ¯”å½’å¹¶æŽ’åºä¸Žå†’æ³¡æŽ’åºä¸Žå¦ã€‚
-}
>>> Nothing < Just (+)
    â€¢ No instance for (Ord (a0 -> a0 -> a0)) arising from a use of â€˜<â€™
        (maybe you haven't applied a function to enough arguments?)
    â€¢ In the expression: Nothing < Just (+)
      In an equation for â€˜itâ€™: it = Nothing < Just (+)
      
>>> read "Just 5" :: Maybe Int
Just 5

>>> show $ Just 5
"Just 5"
```

Maybeç±»åž‹æœ‰ä»€ä¹ˆä½œç”¨å‘¢ï¼Ÿç®€å•åœ°è¯´ï¼ŒMaybe ç±»åž‹æ˜¯ä¸€ç§ç®€å•çš„ç¨‹åºå¤„ç†å¼‚å¸¸çš„æ–¹å¼ï¼Œå› ä¸ºæœ‰äº›æ—¶å€™ï¼Œç¨‹åºéœ€è¦å¸¦ç€å‡ºçŽ°çš„å¼‚å¸¸ç»§ç»­è¿è¡Œï¼Œè€Œä¸æ˜¯ç®€å•åœ°ä¹…æŠ›å‡ºå¼‚å¸¸ç„¶åŽç»ˆæ­¢ã€‚å½“å‡ºçŽ°å¼‚å¸¸çš„æ—¶å€™ï¼Œè¿”å›ž Nothingï¼Œæ¯”å¦‚ï¼ŒHead [] çš„æ—¶å€™å°±æŠ›å‡ºå¼‚å¸¸ã€‚

```haskell
>>> head []
*** Exception: Prelude.head: empty list

-- ä½¿ç”¨ Maybe æ¥å†™ä¸€ä¸ªä¸å‡ºçŽ°å¼‚å¸¸çš„ã€å®‰å…¨çš„ head å‡½æ•°
safeHead :: [a] -> Maybe a
safeHead [] = Nothing
safeHead (x:xs) = Just x
```

#### ç±»åž‹æž„é€ å™¨

**åƒ Maybe éœ€è¦å…¶å®ƒç±»åž‹ä½œä¸ºå‚æ•°æ¥æž„é€ ä¸€ä¸ªæ–°çš„ç±»åž‹çš„ç±»åž‹ï¼Œè¢«ç§°ä¸ºç±»åž‹æž„é€ å™¨ï¼ˆtype constructorï¼‰ã€‚**

**ç±»åž‹çš„ç±»åž‹ç§°ä¸º kind**ã€‚

\* æ˜¯ä¸€ä¸ªé›¶å…ƒç±»åž‹æž„é€ å™¨ï¼ˆnullary type constructorï¼‰çš„ kindï¼Œè¿™ç§ç±»åž‹æž„é€ å™¨ä¸éœ€è¦å…¶å®ƒç±»åž‹åšä¸ºå‚æ•°ï¼Œè‡ªå·±æœ¬èº«å°±æ˜¯ä¸€ä¸ªâ€œå®Œæ•´çš„â€ç±»åž‹ï¼Œæ¯”å¦‚ï¼Œ Maybe Bool :: * ä¸Ž Maybe Int :: * éƒ½æ˜¯å®Œæ•´çš„ç±»åž‹ã€‚

Haskell ä¸­åœ¨ GHCi é‡Œä½¿ç”¨ :kindï¼ˆç®€å†™ä¸º:kï¼‰ æ¥æŸ¥è¯¢ä¸€ä¸ªç±»åž‹æž„é€ å™¨çš„ kind ã€‚

```haskell
>>> :k Int
Int :: *

>>> :k Maybe
Maybe :: * -> *

{-
Maybe Int æ˜¯ä¸€ä¸ªä¸éœ€è¦å…¶å®ƒç±»åž‹è¾“å…¥çš„kindã€‚
è¿™é‡Œçš„ Int ç±»åž‹è¢«åº”ç”¨åˆ°äº† Maybe ç±»åž‹æž„é€ å™¨ï¼Œç§°ä¸ºå®ƒçš„å‚æ•°æ›¿æ¢äº†ç¬¬ä¸€ä¸ªæ˜Ÿå·ä»Žè€Œå¾—åˆ°äº†ä¸€ä¸ªå®Œæ•´çš„ç±»åž‹ã€‚
è¿™ä¸Žå‡½æ•°è½½åº”ç”¨æ—¶ï¼Œå‚æ•°çš„ç±»åž‹æ›¿æ¢äº†å‡½æ•°ç±»åž‹ç­¾åä¸­ç®­å¤´å‰çš„ç±»åž‹æ˜¯ä¸€æ ·çš„é“ç†ã€‚ 
-}
>>> :k Maybe Int
Maybe Int :: *
```

é™¤äº† Maybe å¤–ï¼ŒHaskell é¢„åŠ è½½åº“ä¸­å¦å¤–ä¸€ä¸ªé‡è¦ç±»åž‹æ˜¯ Eitherï¼Œç§°ä¸º â€œæˆ–è€…â€ ç±»åž‹ã€‚å®ƒéœ€è¦ä¸¤ä¸ªä¸åŒçš„ç±»åž‹ä½œä¸ºè¾“å…¥ï¼Œç»„åˆæˆä¸€ä¸ªæ–°çš„ç±»åž‹ã€‚å¸¸å¸¸åŒæ—¶éœ€è¦ä¸€ç§ç±»åž‹æˆ–å¦ä¸€ç§ç±»åž‹çš„æ—¶å€™ç”¨åˆ°ã€‚

**Either æ˜¯ä¸€ç§éœ€è¦ä¸¤ä¸ªç±»åž‹æ¥å…±åŒæž„æˆçš„ç±»åž‹æž„é€ å™¨ã€‚Either çš„å®šä¹‰æ˜¯**ï¼š

```haskell
data Either a b = Left a | Right b 

>>> :k Either
Either :: * -> * -> *
```

ç›¸æ¯”äºŽ Maybe ç±»åž‹ï¼Œå¦‚æžœç”¨Either æ¥å¤„ç†å¼‚å¸¸æœ‰æ—¶æ—¶ä¸€ä¸ªæ›´å¥½çš„é€‰æ‹©ï¼Œå› ä¸ºæˆ‘ä»¬ä¸ä½†å¯ä»¥çŸ¥é“è¿ç®—è¿‡ç¨‹æœ‰å¼‚å¸¸ï¼Œè¿˜å¯ä»¥å­˜å‚¨å¼‚å¸¸çš„ä¿¡æ¯ï¼Œè€Œ Maybe ä¸­ Nothingå´æ— æ³•åšåˆ°è¿™ä¸€ç‚¹ã€‚



åœ¨Haskell ä¸­ï¼Œå°†ä¸¤ä¸ªç±»åž‹å¯èƒ½ä¸åŒçš„åˆ—è¡¨åˆæˆä¸€ä¸ªåˆ—è¡¨ã€‚

```haskell
disjoint :: [a] -> [b] -> [Either a b]
disjoint as bs = map Left as ++ map Right bs

>>> disjoint [1..5] ['a' ..'d'] 
[Left 1,Left 2,Left 3,Left 4,Left 5,Right 'a',Right 'b',Right 'c',Right 'd']

```

å½“éœ€è¦æŠŠEither ä¸­çš„å€¼æ˜ å°„ä¸ºå¦ä¸€ä¸ªå€¼æ—¶ï¼Œè¦ä¸º Left äºŽ Right åˆ†åˆ«æä¾›ä¸€ä¸ªå‡½æ•°ï¼Œè¿™ä¸¤ä¸ªå‡½æ•°è¿”å›žçš„ç±»åž‹ç›¸åŒï¼Œåœ¨è¿™é‡Œéƒ½ä¸º c ç±»åž‹ï¼š

```haskell
either :: (a -> c) -> (b -> c) -> Either a b -> c
either f _ (Left x) = f x
either _ g (Right y) = g y
```

ä¹Ÿå¯ä»¥å°†ä¸€ä¸ª Either ç±»åž‹çš„åˆ—è¡¨åˆ†æˆä¸¤ä¸ªåˆ—è¡¨ï¼Œè¿™ä¸ªç›¸å½“äºŽ disjoint çš„åå‡½æ•°ï¼š

```haskell
either' :: (a -> c) -> (b -> c) -> Either a b -> c
either' f _ (Left x) = f x
either' _ g (Right y) = g y

partitionEithers' :: [Either a b] -> ([a], [b])
partitionEithers' = foldr (either' left right) ([],[])
         where
              left  a (l, r) = (a:l ,r)
              right a (l, r) = (l, a:r)

>>> partitionEithers' [Left 1,Left 2,Left 3,Left 4,Left 5,Right 'a',Right 'b',Right 'c',Right 'd']
([1,2,3,4,5],"abcd")

```
```haskell
-- å’ŒäºŒå…ƒå…ƒç»„ (a, b) æ˜¯ç­‰ä»·çš„
data Pair a b = Pair a b

pfirst (Pair a b) = a
psecond (Pair a b) = b

>>> :t (,)
(,) :: a -> b -> (a, b)

-- (1, 2)
-- å¯ä»¥å†™æˆ (,) 1 2

>>> :t (,,)
(,,) :: a -> b -> c -> (a, b, c)

-- å…ƒç»„çš„æ•°æ®æž„é€ å™¨å¯ä»¥ä½¿ç”¨ TupleSections è¯­è¨€æ‰©å±•æ¥åšéƒ¨åˆ†åº”ç”¨
>>> :set -XTupleSections
>>> :t (,,5)
(,,5) :: Num t => t2 -> t1 -> (t2, t1, t)

-- å¾ˆæ˜¾ç„¶ï¼Œä¸‰å…ƒå…ƒç»„éœ€è¦3ä¸ªç±»åž‹å‚æ•°é¤èƒ½è¿”å›ž * ï¼Œæ‰€ä»¥å®ƒçš„kindä¸º * -> * -> * -> *
>>> :k (,,)
(,,) :: * -> * -> * -> *
```

#### å‡½æ•°ç±»åž‹

 a -> b  ä¸ºä¸€ä¸ªå‡½æ•°çš„ç±»åž‹ï¼Œå®ƒä¹Ÿæ˜¯æœ‰ç±»åž‹æž„é€ å™¨çš„ã€‚å®ƒçš„ç±»åž‹æž„é€ å™¨æ˜¯ (->) ï¼Œä¹Ÿå¯ä»¥å†™ä½œ (->) a bã€‚ä½†å®ƒæ˜¯åµŒå…¥åœ¨Haskellä¸­çš„ï¼Œä¸æ˜¯ç›´æŽ¥å®šä¹‰çš„ï¼Œå®ƒçš„ kindä¸º *-> *-> *ã€‚

```haskell
>>> :k (->)
(->) :: * -> * -> *
```

å¯ä»¥çœ‹åˆ°å³ä¾¿æ˜¯å‡½æ•°è¿™æ ·çš„ç±»åž‹ä¹Ÿæ˜¯é€šè¿‡æž„é€ æ¥å®šä¹‰çš„:

```haskell
>>> :i (->)
data (->) t1 t2         -- Defined in â€˜GHC.Primâ€™
```

### é€’å½’ç±»åž‹

**é€’å½’ç±»åž‹**ï¼Œå®šä¹‰ç±»åž‹æ—¶ç”¨åˆ°äº†æ­£åœ¨å®šä¹‰çš„è¯¥ç±»åž‹æœ¬èº«ã€‚

æ•°å­¦ä¸­çš„è‡ªç„¶åŽå¯ä»¥æ—¶é€’å½’å®šä¹‰çš„ï¼Œç±»åž‹çš„åå­—å®šä¹‰å¯ä»¥å–ä¸ºNatã€‚é¦–å…ˆï¼Œè‡ªç„¶æ•°æ—¶ä»Ž0å¼€å§‹çš„ï¼Œ0å°±æ˜¯é€’å½’å®šä¹‰çš„åŸºæœ¬æƒ…å†µï¼Œè¿™é‡Œå®šä¹‰ä¸ºZeroï¼Œç„¶åŽå…¶å®ƒæ¯ä¸€ä¸ªè‡ªç„¶æ•°éƒ½æœ‰ä¸€ä¸ªåŽç»§ï¼ˆsuccessorï¼Œä¹Ÿæœ‰è¯‘ä¸ºè·Ÿéšçš„ï¼‰ï¼Œä¹Ÿå°±æ˜¯æ¯”å½“å‰çš„æ•°å¤§1çš„æ•°ï¼Œè¿™ä¸ªåŽç»§ä¹Ÿæ˜¯ä¸€ä¸ªè‡ªç„¶æ•°ï¼Œå®šä¹‰ä¸º Succ Natï¼Œä¸€ä¸ªè‡ªç„¶æ•°çš„åŽç»§ã€‚è¿™å°±æ˜¯è‡ªç„¶æ•°çš„é€’å½’å®šä¹‰ã€‚

```haskell
data Nat = Zero | Succ Nat deriving (Show, Eq, Ord)

natToint :: Nat -> Int
natToint Zero = 0
natToint (Succ n) = 1 + natToint n

int2nat :: Int -> Nat
int2nat 0 = Zero
int2nat n = Succ $ int2nat (n - 1)
-- ä¹Ÿå¯ä»¥ä½¿ç”¨å¦‚ä¸‹æ¨¡å¼åŒ¹é…
-- int2nat (n+1) = Succ $ int2nat n

>>> int2nat 10
Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ Zero)))))))))

>>> natToint $ Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ Zero)))))))))
10

-- å®žçŽ° Nat ç±»åž‹çš„åŠ æ³•
-- è¿­ä»£é€’å½’å®žçŽ°
add :: Nat -> Nat -> Nat
add Zero n = n
add (Succ m) n = Succ $ add m n

-- å°¾é€’å½’å®žçŽ°
add :: Nat -> Nat -> Nat
add Zero n = n
add (Succ m) n = add m $ Succ n
```
### æ‚åˆå®šä¹‰ç±»åž‹

åœ¨å®šä¹‰ç±»åž‹çš„æ—¶å€™ï¼Œå¾ˆå°‘æœ‰æœºä¼šèƒ½çœ‹åˆ°ä¸€ä¸ªç±»åž‹æ˜¯é€šè¿‡ç®€å•çš„æ–¹å¼å®šä¹‰çš„ï¼Œå¸¸å¸¸ä¼šç”¨åˆ°å¤šç§å®šä¹‰çš„æ–¹å¼ã€‚

#### æžšä¸¾æž„é€ çš„ç±»åž‹

```haskell
data Shape = Circle Float | Rect Float Float deriving(Show, Eq)

-- æ·»åŠ è®¿é—®å™¨å‡½æ•°
data Shape = Circle {
                radius :: Float
            } |
            Rect {
                len :: Float,
                width :: Float
            } deriving(Show, Eq)

-- è®¡ç®—é¢ç§¯
area :: Shape -> Float
area (Circle r) = pi * r ^ 2
area (Rect a b) = a * b

data Person = Person {
    name :: String,
    age :: Int,
    sex :: Bool
    }
-- åœ¨æ¨¡å¼åŒ¹é…æ—¶ï¼Œä¸éœ€è¦æŠŠæ‰€æœ‰å±žæ€§éƒ½å†™å‡ºæ¥ï¼Œä¸‹é¢çš„ä»£ç å¹¶æ²¡æœ‰åŒ¹é… age
showPerson :: Person -> String
showPerson (Person {name = str, sex = s}) = str ++ show s
```

#### æžšä¸¾é€’å½’å®šä¹‰

```haskell
-- æžšä¸¾å’Œé€’å½’å®šä¹‰çš„ç±»åž‹
data BoolExp = TRUE | FALSE | IF BoolExp BoolExp BoolExp deriving (Show, Eq)

eval :: BoolExp -> Bool
eval TRUE = True
eval FALSE = False
eval (IF con b1 b2) | eval con == True  = eval b1
                    | eval con == False = eval b2
                    

-- ä¸Šé¢çš„é€’å½’çš„ä¼°å€¼è®¡ç®—çš„å®žé™…è¿è¡Œè¿‡ç¨‹éœ€è¦ä¸æ–­åœ¨å†…å­˜ä¸Šè¿›è¡Œå †æ ˆæ“ä½œï¼Œå¯ä»¥ç”¨ä¸€ä¸ªåˆ—è¡¨æ¥ä»£æ›¿è¿™ä¸ªè¿‡ç¨‹ï¼š
data BoolExp = TRUE | FALSE | IF BoolExp BoolExp BoolExp deriving (Show, Eq)

eval :: BoolExp -> Bool
eval TRUE = True
eval FALSE = False
eval (IF con b1 b2) | eval con == True  = eval b1
                    | eval con == False = eval b2

eval' :: [BoolExp] -> Bool
eval' [TRUE] = True
eval' [FALSE] = False
eval' ((IF TRUE b1 b2):xs) = eval'(b1:xs)
eval' ((IF FALSE b1 b2):xs) = eval'(b2:xs)
eval' (l@(IF con b1 b2):xs) = eval'(con:l:xs)
eval' (TRUE:(IF con b1 b2):xs) = eval' (b1:xs)
eval' (FALSE:(IF con b1 b2):xs) = eval' (b2:xs)
-- test = IF (IF FALSE FALSE TRUE) (IF FALSE TRUE FALSE) FALSE
```

#### å‚æ•°åŒ–é€’å½’ç±»åž‹

é¢„åŠ è½½çš„åº“ä¸­å®šä¹‰äº†ä¸€ä¸ªéžå¸¸é‡è¦çš„ç±»åž‹ï¼Œå°±æ˜¯åˆ—è¡¨ï¼Œå®ƒå°±æ˜¯ç”¨äº†å‚æ•°åŒ–ä¸Žé€’å½’çš„æ–¹å¼å®šä¹‰çš„ã€‚

```haskell
>>> :i []
data [] a = [] | a : [a]        -- Defined in â€˜GHC.Typesâ€™

{-
 å®šä¹‰ä¸€ä¸ªåˆ—è¡¨
 åˆ—è¡¨è¦ä¹ˆä¸ºç©ºåˆ—è¡¨ï¼Œå®šä¹‰ä¸ºNilï¼Œé‚£ä¹ˆæ—¶ä¸€ä¸ª a ç±»åž‹çš„å…ƒç´ ç»“åˆä¸€ä¸ª a ç±»åž‹çš„åˆ—è¡¨ã€‚è¿™é‡Œï¼ŒNil ä¸ºé€’å½’å®šä¹‰çš„åŸºæœ¬æƒ…å†µç›¸å½“äºŽåˆ—è¡¨å®šä¹‰ä¸­çš„ []ï¼Œè€Œ Cons a (List a)ä¸ºé€’å½’å®šä¹‰ã€‚Cons æ—¶ä¸€ä¸ªæ•°æ®çš„æž„é€ å™¨ï¼Œåœ¨è¿™é‡Œç›¸å½“äºŽ (:) è¿ç®—ç¬¦ã€‚List æ—¶ç±»åž‹çš„åå­—ï¼ŒNil ä¸Ž Cons ä¸ºæž„é€ å™¨çš„å‡½æ•°ã€‚
-}
data List a = Nil | Cons a (List a) deriving (Eq, Show)

-- æ—¢ç„¶å®šä¹‰List å’Œ Haskell ä¸­å®šä¹‰çš„åˆ—è¡¨çš„å½¢å¼æ—¶ä¸€æ ·çš„ä»–ä»¬æ—¶å®šä»·çš„ï¼Œé‚£ä¹ˆä»–ä»¬ä¹‹é—´å¯ä»¥ç›¸äº’è½¬æ¢
myListToList Nil = []
myListToList (Cons x xs) = x : (myListToList xs)

listToMyList [] = Nil
listToMyList(x:xs) = Cons x (listToMyList xs)
```


## ç±»åž‹çš„åŒæž„

åœ¨ä¸Šé¢ï¼Œå®šä¹‰çš„åˆ—è¡¨ç±»åž‹ä¸Ž Haskell ä¸­çš„åˆ—è¡¨ç±»åž‹åŠŸèƒ½æ˜¯ç›¸åŒçš„ã€‚è¿™é‡Œçš„ç›¸åŒå…¶å®žå°±æ˜¯æŒ‡ä¸¤ä¸ªç±»åž‹â€ç­‰ä»·â€œï¼Œè¿™ç§ç­‰ä»·ç§°ä¸º**åŒæž„ï¼ˆisomorphismï¼‰**ã€‚å¦‚æžœä¸¤ä¸ªç±»åž‹ A ä¸Ž B ä¹‹é—´å¯ä»¥ç›¸äº’è½¬æ¢ï¼Œä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬å¯ä»¥å®šä¹‰å‡ºä¸¤ä¸ªè½¬æ¢å‡½æ•°ï¼Œå¹¶ä¸”è¿™ä¸¤ä¸ªå‡½æ•°å‡ä¸ºä¸€ä¸€å¯¹åº”çš„å‡½æ•°ä¸”äº’ä¸ºåå‡½æ•°ï¼Œåˆ™å¯ç§°ç±»åž‹ A ä¸Ž Bæ˜¯åŒæž„çš„ã€‚

**åŒæž„çš„ç±»åž‹**ï¼šå¯¹äºŽä¸¤ä¸ªç±»åž‹ A ä¸Ž Bï¼Œè‹¥å¯ä»¥å®šä¹‰ f :: A - > B å°† Aæ˜ å°„åˆ° Bï¼Œå¹¶ä¸”å¯ä»¥å®šä¹‰ f çš„åå‡½æ•° g :: B -> A å°† B æ˜ å°„åˆ° A ä¸”æ»¡è¶³ f . g = idÊ™ å’Œ g . f = idð˜ˆ ã€‚ï¼ˆ **.** ä¸ºå¤åˆå‡½æ•°è¿ç®—ç¬¦ï¼Œ  idð˜ˆ ä¸Ž idÊ™ åˆ†åˆ«æ˜¯ A ä¸Ž B ç±»åž‹ä¸Šçš„æ’æŒ‡æ˜ å°„ï¼‰ï¼Œé‚£ä¹ˆè¯´ç±»åž‹ A ä¸Ž ç±»åž‹ B ä¸ºåŒæž„çš„  è®°åš Aâ‰ƒB ã€‚

**åŒæž„æ˜ å°„**ï¼šå¯¹äºŽç±»åž‹ A ä¸Ž Bï¼Œå‡½æ•°  f :: A - > B ä¸ºåŒæž„æ˜ å°„ï¼Œè‹¥å­˜åœ¨ä¸€ä¸ªå‡½æ•°ï¼ˆç§°ä¸ºé€†ï¼ˆinverseï¼‰å‡½æ•°ï¼‰ g :: B -> A æ»¡è¶³ï¼šf . g = idÊ™ ï¼Œ g . f = idð˜ˆ 

```haskell
                          -- åŒæž„ç±»åž‹ç¤ºæ„å›¾
						  | â†   g   â†    |
                    idA â†”ï¸Ž A               B â†”ï¸Ž idB
                          | â†’    f   â†’    |                  
```

ä»»æ„ç±»åž‹éƒ½ä¸Žè‡ªå·±åŒæž„ï¼Œå³ Aâ‰ƒA ã€‚**å³ â‰ƒ æ˜¯è‡ªåçš„ã€‚(reflexive)**

å¦‚æžœ A ä¸Ž B åŒæž„ï¼Œé‚£ä¹ˆ B ä¸Ž A ä¹ŸåŒæž„ï¼Œå³ Aâ‰ƒB   =>  Bâ‰ƒAã€‚**å³ â‰ƒ æ˜¯å¯¹ç§°çš„ã€‚ï¼ˆsynmetricï¼‰**

å¦‚æžœ  Aâ‰ƒB  å¹¶ä¸” Bâ‰ƒCï¼Œé‚£ä¹ˆ Aâ‰ƒC ï¼Œå³ Aâ‰ƒB  ^ Bâ‰ƒC  => Aâ‰ƒCã€‚**å³ â‰ƒ æ˜¯ä¼ é€’çš„ã€‚(reflexive)**



List å’Œ Haskell å†…ç½®çš„åˆ—è¡¨[] æ˜¯åŒæž„çš„ï¼Œä¸¤ä¸ªç±»åž‹åŒæž„åˆ™è¯´æ˜Žå®šä¹‰åœ¨ [] ä¸­çš„å‡½æ•°åœ¨ List ä¸­ä¹Ÿå¯ä»¥å®šä¹‰ã€‚

```haskell
listHead :: List a -> a
listHead Nil = undefined
listHead (Cons x xs) = x
```

å¯¹äºŽæžšä¸¾ç±»åž‹ï¼Œå¦‚æžœæ‰€æžšä¸¾çš„å€¼çš„ä¸ªæ•°æ˜¯ç›¸ç­‰çš„ã€‚é‚£ä¹ˆå¯ä»¥å†™ä¸¤ä¸ªå‡½æ•°ç›¸äº’è½¬æ¢å¹¶ä¸”èƒ½å¤Ÿæ»¡è¶³åŒæž„çš„æ¡ä»¶ã€‚

å¯¹äºŽè¿™ç§æƒ…å†µï¼Œå¯ä»¥**æ€»ç»“å‡ºæ›´ä¸ºä¸€èˆ¬çš„è§„åˆ™ï¼šç»™å®šä¸¤ä¸ªä½¿ç”¨æžšä¸¾ç±»åž‹ï¼Œè‹¥å®ƒä»¬ä¹‹ä¸­å®šä¹‰çš„å€¼çš„ä¸ªæ•°ç›¸ç­‰ï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ªç±»åž‹æ˜¯åŒæž„çš„ã€‚**

```haskell
data ThreeNum = One | Two | Three
data Level  = Low | Middle | High

f:: ThreeNum -> Level
f One = Low
f Two = Middle
f Three = High

g :: Level -> ThreeNum
g Low = One
g Middle = Two
g  High = Three
```
åˆ—è¡¨æ˜¯ä¸€ä¸ªå‚æ•°åŒ–å®šä¹‰ç±»åž‹ï¼Œè‹¥ç»™å®šè¿™ä¸ªç±»åž‹å‚æ•°ä¸º Unitï¼Œå¹¶ä¸” Unit ç±»åž‹ä¸­ä»…å®šä¹‰æœ‰ä¸€ä¸ªå€¼ â€”â€” Unitï¼Œé‚£ä¹ˆå¯ä»¥çœ‹å‡ºï¼Œ List Unit ä¸ŽNat æ˜¯åŒæž„çš„ã€‚å¹¶ä¸”æˆ‘ä»¬å®šä¹‰çš„ Unit ä¸Ž Haskell å†…ç½®çš„ () ç±»åž‹æ˜¯åŒæž„çš„ï¼Œå³ () â‰ƒ Unit

```haskell
data Unit = Unit deriving (Eq, Show)
data List a = Nil | Cons a (List a) deriving (Eq, Show)
data Nat = Zero | Succ Nat deriving (Eq, Show)

-- data List Unit = Nil | Cons Unit (List List)
-- data Nat = Zero | Succ Nat

-- è½¬æ¢å‡½æ•°
list2Nat Nil = Zero
list2Nat (Cons x xs) = Succ (list2Nat xs)

nat2List Zero = Nil
nat2List (Succ n) = Cons Unit (nat2List n)

-- æ‰€ä»¥ï¼Œå¯ä»¥å¾—åˆ°ç»“è®ºï¼š List Unit â‰ƒ Nat
```


ä¸‹é¢ä»‹ç»ä¸€ä¸‹æ–°ç±»åž‹çš„æž„å»ºä¸Žæ›´ä¸ºä¸€èˆ¬çš„åŒæž„ç±»åž‹ã€‚è‹¥ç»™å®šç±»åž‹ Aã€Bã€Cï¼Œé‚£ä¹ˆä¸‹åˆ—ç»™äºˆå®ƒä»¬çš„å…ƒç¥–æ˜¾ç„¶ä¹Ÿæ˜¯åŒæž„çš„ï¼š

(A, B) â‰ƒ (B, A)

((A, B), C) â‰ƒ (A, (B, C)) â‰ƒ (A,B,C)

å‡½æ•°ç±»åž‹ä¹‹é—´ä¹Ÿå¯ä»¥æ˜¯åŒæž„çš„ï¼Œåªæ˜¯æ­¤æ—¶å¯¹åº”çš„è½¬æ¢å‡½æ•° f ä¸Ž g å‡ä¸ºé«˜é˜¶å‡½æ•°ã€‚

A -> (B, C) â‰ƒ A -> (C, B)

(A, B) -> C â‰ƒ A -> B -> C ï¼ˆä½¿ç”¨ucrry å’Œ uncurry è½¬æ¢å‡½æ•°ï¼‰

**å…ƒç¥–ç±»åž‹**ï¼Œåªæœ‰ä¸€ä¸ªæž„é€ å™¨ï¼Œæž„é€ å™¨å†…å«æœ‰å¤šä¸ªç±»åž‹ï¼Œåœ¨ä¹¦é¢è¡¨è¾¾å¼å¸¸å¸¸ç”¨ X æ¥è¡¨ç¤ºï¼Œå¦‚äºŒå…ƒå…ƒç»„å¯ä»¥å®šä¹‰ä¸º data Pair A B = Pair A Bã€‚è®°ä½œ A X Bï¼Œç§°ä½œ **ç§¯ç±»åž‹ï¼ˆproduct typeï¼‰**ï¼Œåœ¨é›†åˆä¸­ç§°ä¸ºç¬›å¡å°”ç§¯ï¼ˆCartesian productï¼‰ã€‚Pair A B ç±»åž‹ä¸­å€¼çš„ä¸ªæ•°æ˜¯ A ä¸Ž B ç±»åž‹çš„å€¼çš„ä¸ªæ•°ä¹‹ç§¯ã€‚å¯ä»¥ç”¨ |X| ç±»åž‹çš„å€¼çš„ä¸ªæ•°ï¼Œé‚£ä¹ˆï¼Œåˆ™æœ‰ï¼Œ |A X B| = |A| X |B|ã€‚

**Eitherç±»åž‹**ï¼Œç”±å¤šä¸ªæž„é€ å™¨ï¼ˆæˆ–ç§°å¤šæ¨¡å¼ï¼ˆmulti-patternï¼‰ï¼‰æžšä¸¾å®šä¹‰çš„ç±»åž‹ï¼Œåˆ™ç”¨ + æ¥è¡¨ç¤ºï¼Œæ¯”å¦‚ data Either A B = Left A | Right Bï¼Œè®°ä½œ A + Bï¼Œç§°ä½œ**å’Œç±»åž‹ï¼ˆsum typeï¼‰**ï¼Œä»Žé›†åˆçš„è§’åº¦å¯ä»¥ç†è§£ä¸ºä¸ç›¸äº¤å¹¶é›†ï¼Œå³ï¼Œåœ¨ç»“åˆä¸¤ä¸ªç±»åž‹æ—¶ï¼Œå³ä¾¿å®ƒä»¬æœ‰é‡åˆçš„å…ƒç´ ï¼Œä½† Left ä¸Ž Right æž„é€ å™¨å°†ä½œä¸ºæ ‡è®°å¯¹å®ƒä»¬åŠ ä»¥åŒºåˆ†ã€‚å¦‚ Either Bool Bool ç±»åž‹ä¸­æœ‰ Left Trueã€Left Falseã€Right Trueã€Right False è¿™4ä¸ªå€¼ï¼Œåº”è¯¥æ³¨æ„åˆ° Left True å’Œ Right True æ˜¯ä¸åŒçš„å€¼ï¼Œè™½ç„¶å®ƒä»¬æ¥è‡ªäºŽåŒä¸€ç§ç±»åž‹ã€‚æ˜¾ç„¶è¿™ä¸ªç±»åž‹å€¼çš„ä¸ªæ•°æ˜¯ A ä¸Ž B ç±»åž‹å€¼çš„ä¸ªæ•°ä¹‹å’Œï¼Œé‚£ä¹ˆï¼Œåˆ™æœ‰ |A + B| = |A| + |B|.

**å‡½æ•°ç±»åž‹**ï¼Œå¦‚æžœæ˜¯ data Fun = Fun (A -> B) è¿™æ ·çš„å‡½æ•°ç±»åž‹ï¼Œè®°ä½œï¼š Bá´¬ï¼Œå³è¿™æ ·çš„å‡½æ•°æœ‰ |B|á´¬| = |Bá´¬|ä¸ªã€‚

åƒ**å¸ƒå°”ç±»åž‹**è¿™æ ·ä»¥å…·ä½“å€¼æˆ–è€…ç§°ä¸º**é›¶å…ƒæž„é€ å™¨**çš„ **â€œå’Œâ€ ç±»åž‹æœ‰æ—¶ç§°ä¸ºç´¯è®¡ç±»åž‹ï¼ˆcountingï¼‰**ï¼Œå¦‚å¸ƒå°”ç±»åž‹å¯ä»¥å†™ä¸º 1 + 1ï¼Œç¬¬ä¸€ä¸ª 1 è¡¨ç¤º Falseï¼Œ ç¬¬äºŒä¸ª 1 è¡¨ç¤º Trueï¼Œå¯ä»¥çœ‹åˆ°ä»–ä¸Ž Either () () åŒæž„ã€‚

```haskell
bool2EitherUnit :: Bool -> Either () ()
bool2EitherUnit False = Left ()
bool2EitherUnit True = Right ()

eitherUnit2Bool :: Either () () -> Bool
eitherUnit2Bool (Left ()) = False
eitherUnit2Bool (Right ()) = True
```

å¯¹äºŽè‡ªç„¶æ•°çš„è‡ªå®š data Nat = Zero | Succ Nat ï¼Œåˆ™å†™ä¸º Nat = 1 + Natï¼Œå¯ä»¥çœ‹åœ¨å®šä¹‰ä¸­ä½¿ç”¨åˆ°äº† Nat æœ¬èº«ï¼Œå› ä¸ºè¿™æ˜¯ä¸€ä¸ªé€’å½’ç±»åž‹ã€‚

**è¿™æ ·ç”± () ç±»åž‹é€šè¿‡ å’Œç±»åž‹ã€ç§¯ç±»åž‹è¿˜æœ‰å‡½æ•°ç±»åž‹ç­‰ç­‰æ–¹å¼ç»„åˆå®šä¹‰å‡ºæ¥çš„ç±»åž‹ç§°ä¸º ä»£æ•°æ•°æ®ç±»åž‹ï¼ˆAlgebraic Data Typeï¼Œç®€å†™ä¸º ADTï¼‰ã€‚**

`data T = Con a1 a2 a3 a4 ... an` ï¼Œè¿™é‡Œä½¿ç”¨çš„å¤šä¸ªå‚æ•°ä¸Žä½¿ç”¨ä¸€ä¸ªå…ƒç»„å®šä¹‰æ—¶ç­‰ä»·çš„ï¼Œ T çš„ç±»åž‹å¯è®°ä½œ a1 Ã— a2 Ã— a3 Ã— a4 Ã— ... anï¼Œè¿™ä¸ªç±»åž‹æ˜¾ç„¶ä¸Ž n å…ƒå…ƒç»„æ˜¯åŒæž„çš„ã€‚ 

`data T = A a b c .. | B d e f .. | C g h i ..| ...`ï¼Œ è¿™é‡Œçš„ T ç±»åž‹å¯ä»¥è®°ä½œ (a Ã— b Ã— c ...) +  (d Ã— e Ã— f â€¦) +  (g Ã— h Ã— i â€¦) + â€¦  ã€‚è¿™æ ·çš„ç±»åž‹ä¹Ÿç§°ä¸º**ä¸€èˆ¬åŒ–çš„ç»“æž„ç±»åž‹**ã€‚



ä¹‹å‰ä»‹ç»çš„å‡ ä¸ªåŒæž„å…³ç³»å¯ä»¥è®°ä½œï¼š

A Ã— B â‰ƒ B Ã— A

(A Ã— B) Ã— C â‰ƒ A Ã— (B Ã— C)

(B Ã— C)á´¬ â‰ƒ (C Ã— B)á´¬

C(á´¬â¨¯á´®) â‰ƒ (Cá´®)á´¬  ï¼ˆä½¿ç”¨ucrry å’Œ uncurry è½¬æ¢å‡½æ•°ï¼‰

è¿˜ç¼ºå°‘è¯æ˜Ž TODO



æ­¤å¤–ï¼Œå¯¹äºŽï¼š A Ã— (B Ã— C) â‰ƒ A Ã— B + A Ã— C

(A, Either B C) å’Œ Either (A, B) (A, C) æ˜¾ç„¶æ˜¯åŒæž„çš„ã€‚

(A, Either B C)        				 ä¸º A * (B + C)

Either (A, B) (A, C)  ä¸º A * B +  A * C ç­‰äºŽ A * (B + C)

```haskell
f :: (a, Either b c) -> Either (a, b) (a, c)
f (a, Left b) = Left (a, b)
f(a, Right c) = Right (a, c)

g ::  Either (a, b) (a, c) -> (a, Either b c)
g (Left (a, b)) = (a, Left b)
g (Right (a, c)) = (a, Right c)
```
è¿™æ ·ï¼Œä½¿ç”¨ **æ¨¡å¼åŒ¹é…** æˆ–è€… **case** æ¥å®šä¹‰åŸºäºŽæŸä¸€ç±»åž‹çš„å‡½æ•°å¼ï¼Œæ¯ä¸€æ¡åŒ¹é…å®žé™…ä¸ŠåŒ¹é…çš„æ˜¯è¯¥**å’Œç±»åž‹**çš„æŸä¸€ä¸ªå˜ä½“ï¼Œå³æŸä¸€ä¸ªæž„é€ å™¨ä¸Žè¯¥æž„é€ å™¨çš„å‚æ•°ï¼Œè¿™ä¸ªå‚æ•°å¯èƒ½æ˜¯ä¸€ä¸ª **ç§¯** **æˆ–è€…ä¸€ä¸ªå‚æ•°**ã€‚è€Œéœ€è¦å¯¹ä¸€ä¸ªå‚æ•°è¿›è¡Œå¤šä¸ªæ¨¡å¼åŒ¹é…åˆ™æ˜¯å› ä¸ºè¯¥ç±»åž‹æ˜¯é€šè¿‡å¤šä¸ªæ•°æ®æž„é€ å™¨çš„å’Œå®šä¹‰çš„ï¼Œä¹Ÿå°±æ˜¯å› ä¸ºè¿™ä¸ªç±»åž‹æœ‰å¤šä¸ªå˜ä½“ï¼Œå¤šç§æ¨¡å¼ã€‚

Either çš„å®šä¹‰å’Œæ¨¡å¼åŒ¹é…å¦‚ä¸‹ï¼š

```haskell
data Either a b = Left a | Right b
f (Left a)  = ...
f (Right b) = ...
```

å¯ä»¥çœ‹åˆ° Either ç±»åž‹æœ‰ä¸¤ä¸ªå˜ä½“æˆ–è€…è¯´ä¸¤ç§æ¨¡å¼ Left ä¸ŽRightï¼Œæ‰€ä»¥æœ‰ä¸¤æ¡åŒ¹é…ï¼Œè€Œæ¯æ¡åŒ¹é…éƒ½ä¼šå¾—åˆ°æž„é€ å™¨ä¸­çš„å‚æ•°ã€‚åŒæ—¶ï¼Œè¯»è€…ä¹Ÿåº”è¯¥æ„è¯†åˆ° Non-exhaustive patterns å¼‚å¸¸çš„åŽŸå› äº†ï¼Œå³åœ¨å®šä¹‰å‡½æ•°æ—¶ï¼Œæ²¡æœ‰æŠŠæ‰€æœ‰çš„æ•°æ®å½¢å¼éƒ½è€ƒè™‘è¿›æ¥ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæœ‰ä¸€äº›å½¢å¼åœ¨æˆ‘ä»¬çš„å‡½æ•°ç§æ²¡æœ‰è¢«å®šä¹‰ï¼Œä½†æ˜¯è°ƒç”¨å‡½æ•°æ—¶å‡ºçŽ°äº†è¿™ç§å½¢å¼æ²¡æœ‰åŒ¹é…ã€‚**åœ¨ç¼–è¯‘çš„è¿‡ç¨‹ä¸­ï¼ŒGHC ä¼šå¯¹è¿™äº›é—æ¼ç»™å‡ºä¸€äº›è­¦å‘Šï¼Œå³ä¾¿å®šä¹‰æ—¶ç¡®å®šä¸ä¼šå‡ºçŽ°è¿™ç§å½¢å¼ï¼Œä¹Ÿæœ€å¥½é€šè¿‡ error æˆ–è€…å…¶å®ƒæ–¹å¼æ¥å®šä¹‰ä¸ä¸Šè¿™ä¸ªç¼ºå£ã€‚**



```haskell
-- ä½¿ç”¨å€¼æž„é€ å™¨ :  åšæ¨¡å¼åŒ¹é…
get4 (_:_:_:x:_) = x
get4 _ = error "error param"

-- å¯ä»¥ä½¿ç”¨ NPlusKPatterns è¯­è¨€æ‰©å±• (n + 1)æ–¹å¼çš„æ¨¡å¼åŒ¹é…ï¼Œä¸æŽ¨èä½¿ç”¨
{-# LANGUAGE  NPlusKPatterns #-}
data Nat = Zero | Succ Nat deriving (Show, Eq, Ord)
int2nat :: Int -> Nat
int2nat 0 = Zero
-- int2nat n = Succ $ int2nat (n - 1)
int2nat (n + 1) = Succ $ int2nat n 
```