Haskell 主要使用 data 与 newtype 关键字来定义新的类型。

定义新的类型后，可能会发现这些类型与之前用过的类型是等价的，这种等价称为同构（isomorphism）。

## 数据类型的定义

### 枚举类型

布尔类型在 Haskell 中就是枚举定义的，这个类型里只有两个值，即 True 与 False。

在 Prelude 中它是这样定义的：

```haskell
data Bool = False | True 
```

**data** 是定义新类型的关键字，后边跟想要定义的类型名称，类型名称首字母要大写。然后**定义布尔类型的值，即 True 与 False**。

布尔类型是一个非常简单的类型，这个类型只可能有两个值，也可以称为两种形式，True 或者 False。这里只需要将它们一次写出，用 "|"分开即可。这种定义的方式可以被称为枚举定义，即定义的值能够以一定的顺序一一地枚举出来。使用模式匹配定义函数时就是匹配 "|"之间不同的定义模式。

定义“星期”类型

```haskell
-- 这里可以先使用 deriving 关键字来让这个类型自动实现一些类型类

data Day = Mon | Tue | Wed | Thu | Fri | Sat | Sun
 deriving (Show, Eq, Ord, Enum)
 
 -- 实现了Show类型类
 >>> Mon
Mon

-- 实现了Eq类型类
>>> Mon == Mon
True

-- 实现了Ord类型类
-- 由于有序类型类Ord是基于相等类型类 Eq 的，因此一定要实现相等类型类 Eq 后才能实现有序类型类 Ord 
>>> Mon < Sun
True

-- 实现了Enum 类型类
>>> [Mon .. Sun]
[Mon,Tue,Wed,Thu,Fri,Sat,Sun]

-- 通过模式匹配实现 tomorrow 函数
-- 这个 tomorrow 函数的实现比较麻烦
tomorrow :: Day -> Day
tomorrow Mon = Tue
tomorrow Tue = Wed
tomorrow Wed = Thu
tomorrow Thu =Fri
tomorrow Fri =Sat
tomorrow Sat =Sun
tomorrow Sun = Mon

{--
由于类型 Day 实现了枚举类型类 Enum 后，有很多函数可以立即使用，如 succ、 pred 及其他的函数，这里简单介绍  succ （successor的简写）函数与 pred (predecessor 的简写)函数。succ 函数会返回参数的下一个枚举类型的值，而 pred 会返回给定参数的前一个枚举类型的值。
--}
-- 如果给定的参数已经为边界值，则会出现异常
tomorrow' :: Day -> Day
tomorrow' Sun = Mon
tomorrow' day = succ day
```

除了以上的 4 个比较常用的类型类，还有可读类型类 Read，即可以使用 read 函数来将一个字符串读成 Day 的类型的数据。

```haskell
data Day = Mon | Tue | Wed | Thu | Fri | Sat | Sun
 deriving (Show, Read)
 
 >>> read "Mon" :: Day 
Mon
```

值得一提的是，如果一个数据类型 a 是可读的，那么依赖于 a 的类型 b 也是可读的。比如，数据 Day 是可读的，以来于 Day 类型的列表 [Day] 也是可读的。

```haskell
>>> read "[Mon, Tue]" :: [Day]
[Mon,Tue]
```

### 构造类型

```haskell
-- 构造 Book 类型
type Name = String
type Author = String
type ISBN = String
type Price = Float

data Book = Book Name Author ISBN Price deriving(Show, Eq)
```

data Book 中的 Book是类型的名称，也称为**类型构造器**（*类型构造器可以有类型参数，即参数化类型*）。

Book Name Author ISBN中的 Book 称为**数据构造器**（data constructor）。

虽然在很多类型的定义中类型的名称与数据构造器的名称是相同的，但绝不能混淆类型构造器和数据构造器，。

其实，数据构造器本身是一种特殊的函数，不过首字母会大写。

```haskell
-- 通过查看 Book 的类型可以知道，构造器本质上是以那些函数作为输入，返回一个 Book 类型的数据的函数
>>> :t Book
Book :: Name -> Author -> ISBN -> Price -> Book

--访问类型中的参数
name   (Book n _ _ _) = n
author (Book _ a _ _) = a
isbn   (Book _ _ i _) = i
price  (Book n _ _ p) = p

>>> name $ Book  "Haskell" "Mark" "45678" 10
"Haskell"
```

Haskell 提供了另一种定义的语法，这个语法使得访问器函数载这个类型定义的同时也被定义出来了。

```haskell
data Book = Book {
         name :: Name,
         author :: Author ,
         isbn :: ISBN,
         price :: Price
       } deriving(Show, Eq)
```

访问器的名称如 name、author 等，被称为**字段名**或者**记录(record)**。

由于是访问Book的函数，所以这些函数都需要一个Book 类型的值作为函数的第一个参数。

```haskell
>>> :t name
name :: Book -> Name

>>> :t author
author :: Book -> Author
```



```haskell
-- 书店中的一些书要涨价，书店需要分别记录原价和涨价后书的信息
incrisePrice :: ([Book], [Book]) -> Book -> Float -> ([Book], [Book])
incrisePrice (b1, b2) b pri = ((b: b1), (Book (name b) (author b) (isbn b) (price b + pri)) : b2)

>>> incrisePrice ([(Book  "Haskell" "Mark" "45678" 10)],[]) (Book  "Scheme" "Jim" "654" 100) 150

([Book {name = "Scheme", author = "Jim", isbn = "654", price = 100.0},Book {name = "Haskell", author = "Mark", isbn = "45678", price = 10.0}],[Book {name = "Scheme", author = "Jim", isbn = "654", price = 250.0}])

-- 重构版本1
incrisePrice (b1, b2) (Book nm ath isbn prc) pri = ((Book nm ath isbn prc):b1, (Book nm ath isbn (prc+pri)):b2)

-- 重构版本2，使用@符号来用一个名字来指代这个构造的数据
incrisePrice (b1, b2) b@(Book nm ath isbn prc) pri = (b:b1, (Book nm ath isbn (prc+pri)):b2)

-- 重构版本3
incrisePrice (b1, b2) b pri = (b:b1, (b{price=pri}):b2)
```
上面讨论的 Book 数据构造器是需要一些其它参数填充的，而有的时候，构造器与值其实并没有显著的区别，比如，可以认为 True 与 False 就是布尔类型的构造器，它们不需要参数称为**零元数据构造器**（**nullary data constructor**）。

### 参数化类型

**参数化类型是需要类型参数的类型**。参数化类型的定义中的类型名称后可以加一个任意的类型参数以供这个类型的数据构造器使用，这样的构造器可以暂时简单理解为一个容器，与构造类型不同，这里的参数可以是任何的多态类型，而不是一个确定的类型。

```haskell
data Maybe a = Nothing | Just a
```

Maybe可以理解为一种容器类型，里面可以放一些东西。Just 内的类型 a 可以是任意的类型，Float、Double、元组 甚至是函数类型。这里 Just 就是一个构造器，这个构造器是一个堕胎类型的函数，它的类型是 a -> Maybe a

```haskell
>>> :i Maybe
data Maybe a = Nothing | Just a         -- Defined in ‘GHC.Base’
instance Eq a => Eq (Maybe a) -- Defined in ‘GHC.Base’
instance Monad Maybe -- Defined in ‘GHC.Base’
instance Functor Maybe -- Defined in ‘GHC.Base’
instance Ord a => Ord (Maybe a) -- Defined in ‘GHC.Base’
instance Read a => Read (Maybe a) -- Defined in ‘GHC.Read’
instance Show a => Show (Maybe a) -- Defined in ‘GHC.Show’
instance Applicative Maybe -- Defined in ‘GHC.Base’
instance Foldable Maybe -- Defined in ‘Data.Foldable’
instance Traversable Maybe -- Defined in ‘Data.Traversable’
instance Monoid a => Monoid (Maybe a) -- Defined in ‘GHC.Base’
```

Maybe类型实现了 Eq、Ord、Read、Show 类型类。

如果 a 可以比较相等，那么 Maybe a 也可以比较相等。

```haskell
>>> Nothing < Just 3
True

{-
这里错误的意思是，函数的类型没有实现有序类，所以不能使用 < 进行比较，在任何语言中函数都是无法直接比较相等还有大小的。
如果有语言比较了函数的相等，它比较的一半是函数的所在地址或者编译成的指令，即无法比归并排序与冒泡排序与否。
-}
>>> Nothing < Just (+)
    • No instance for (Ord (a0 -> a0 -> a0)) arising from a use of ‘<’
        (maybe you haven't applied a function to enough arguments?)
    • In the expression: Nothing < Just (+)
      In an equation for ‘it’: it = Nothing < Just (+)
      
>>> read "Just 5" :: Maybe Int
Just 5

>>> show $ Just 5
"Just 5"
```

Maybe类型有什么作用呢？简单地说，Maybe 类型是一种简单的程序处理异常的方式，因为有些时候，程序需要带着出现的异常继续运行，而不是简单地久抛出异常然后终止。当出现异常的时候，返回 Nothing，比如，Head [] 的时候就抛出异常。

```haskell
>>> head []
*** Exception: Prelude.head: empty list

-- 使用 Maybe 来写一个不出现异常的、安全的 head 函数
safeHead :: [a] -> Maybe a
safeHead [] = Nothing
safeHead (x:xs) = Just x
```

#### 类型构造器

**像 Maybe 需要其它类型作为参数来构造一个新的类型的类型，被称为类型构造器（type constructor）。**

**类型的类型称为 kind**。

\* 是一个零元类型构造器（nullary type constructor）的 kind，这种类型构造器不需要其它类型做为参数，自己本身就是一个“完整的”类型，比如， Maybe Bool :: * 与 Maybe Int :: * 都是完整的类型。

Haskell 中在 GHCi 里使用 :kind（简写为:k） 来查询一个类型构造器的 kind 。

```haskell
>>> :k Int
Int :: *

>>> :k Maybe
Maybe :: * -> *

{-
Maybe Int 是一个不需要其它类型输入的kind。
这里的 Int 类型被应用到了 Maybe 类型构造器，称为它的参数替换了第一个星号从而得到了一个完整的类型。
这与函数载应用时，参数的类型替换了函数类型签名中箭头前的类型是一样的道理。 
-}
>>> :k Maybe Int
Maybe Int :: *
```

除了 Maybe 外，Haskell 预加载库中另外一个重要类型是 Either，称为 “或者” 类型。它需要两个不同的类型作为输入，组合成一个新的类型。常常同时需要一种类型或另一种类型的时候用到。

**Either 是一种需要两个类型来共同构成的类型构造器。Either 的定义是**：

```haskell
data Either a b = Left a | Right b 

>>> :k Either
Either :: * -> * -> *
```

相比于 Maybe 类型，如果用Either 来处理异常有时时一个更好的选择，因为我们不但可以知道运算过程有异常，还可以存储异常的信息，而 Maybe 中 Nothing却无法做到这一点。



在Haskell 中，将两个类型可能不同的列表合成一个列表。

```haskell
disjoint :: [a] -> [b] -> [Either a b]
disjoint as bs = map Left as ++ map Right bs

>>> disjoint [1..5] ['a' ..'d'] 
[Left 1,Left 2,Left 3,Left 4,Left 5,Right 'a',Right 'b',Right 'c',Right 'd']

```

当需要把Either 中的值映射为另一个值时，要为 Left 于 Right 分别提供一个函数，这两个函数返回的类型相同，在这里都为 c 类型：

```haskell
either :: (a -> c) -> (b -> c) -> Either a b -> c
either f _ (Left x) = f x
either _ g (Right y) = g y
```

也可以将一个 Either 类型的列表分成两个列表，这个相当于 disjoint 的反函数：

```haskell
either' :: (a -> c) -> (b -> c) -> Either a b -> c
either' f _ (Left x) = f x
either' _ g (Right y) = g y

partitionEithers' :: [Either a b] -> ([a], [b])
partitionEithers' = foldr (either' left right) ([],[])
         where
              left  a (l, r) = (a:l ,r)
              right a (l, r) = (l, a:r)

>>> partitionEithers' [Left 1,Left 2,Left 3,Left 4,Left 5,Right 'a',Right 'b',Right 'c',Right 'd']
([1,2,3,4,5],"abcd")

```
```haskell
-- 和二元元组 (a, b) 是等价的
data Pair a b = Pair a b

pfirst (Pair a b) = a
psecond (Pair a b) = b

>>> :t (,)
(,) :: a -> b -> (a, b)

-- (1, 2)
-- 可以写成 (,) 1 2

>>> :t (,,)
(,,) :: a -> b -> c -> (a, b, c)

-- 元组的数据构造器可以使用 TupleSections 语言扩展来做部分应用
>>> :set -XTupleSections
>>> :t (,,5)
(,,5) :: Num t => t2 -> t1 -> (t2, t1, t)

-- 很显然，三元元组需要3个类型参数餐能返回 * ，所以它的kind为 * -> * -> * -> *
>>> :k (,,)
(,,) :: * -> * -> * -> *
```

#### 函数类型

 a -> b  为一个函数的类型，它也是有类型构造器的。它的类型构造器是 (->) ，也可以写作 (->) a b。但它是嵌入在Haskell中的，不是直接定义的，它的 kind为 *-> *-> *。

```haskell
>>> :k (->)
(->) :: * -> * -> *
```

可以看到即便是函数这样的类型也是通过构造来定义的:

```haskell
>>> :i (->)
data (->) t1 t2         -- Defined in ‘GHC.Prim’
```

### 递归类型

**递归类型**，定义类型时用到了正在定义的该类型本身。

数学中的自然后可以时递归定义的，类型的名字定义可以取为Nat。首先，自然数时从0开始的，0就是递归定义的基本情况，这里定义为Zero，然后其它每一个自然数都有一个后继（successor，也有译为跟随的），也就是比当前的数大1的数，这个后继也是一个自然数，定义为 Succ Nat，一个自然数的后继。这就是自然数的递归定义。

```haskell
data Nat = Zero | Succ Nat deriving (Show, Eq, Ord)

natToint :: Nat -> Int
natToint Zero = 0
natToint (Succ n) = 1 + natToint n

int2nat :: Int -> Nat
int2nat 0 = Zero
int2nat n = Succ $ int2nat (n - 1)
-- 也可以使用如下模式匹配
-- int2nat (n+1) = Succ $ int2nat n

>>> int2nat 10
Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ Zero)))))))))

>>> natToint $ Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ Zero)))))))))
10

-- 实现 Nat 类型的加法
-- 迭代递归实现
add :: Nat -> Nat -> Nat
add Zero n = n
add (Succ m) n = Succ $ add m n

-- 尾递归实现
add :: Nat -> Nat -> Nat
add Zero n = n
add (Succ m) n = add m $ Succ n
```
### 杂合定义类型

在定义类型的时候，很少有机会能看到一个类型是通过简单的方式定义的，常常会用到多种定义的方式。

#### 枚举构造的类型

```haskell
data Shape = Circle Float | Rect Float Float deriving(Show, Eq)

-- 添加访问器函数
data Shape = Circle {
                radius :: Float
            } |
            Rect {
                len :: Float,
                width :: Float
            } deriving(Show, Eq)

-- 计算面积
area :: Shape -> Float
area (Circle r) = pi * r ^ 2
area (Rect a b) = a * b

data Person = Person {
    name :: String,
    age :: Int,
    sex :: Bool
    }
-- 在模式匹配时，不需要把所有属性都写出来，下面的代码并没有匹配 age
showPerson :: Person -> String
showPerson (Person {name = str, sex = s}) = str ++ show s
```

#### 枚举递归定义

```haskell
-- 枚举和递归定义的类型
data BoolExp = TRUE | FALSE | IF BoolExp BoolExp BoolExp deriving (Show, Eq)

eval :: BoolExp -> Bool
eval TRUE = True
eval FALSE = False
eval (IF con b1 b2) | eval con == True  = eval b1
                    | eval con == False = eval b2
                    

-- 上面的递归的估值计算的实际运行过程需要不断在内存上进行堆栈操作，可以用一个列表来代替这个过程：
data BoolExp = TRUE | FALSE | IF BoolExp BoolExp BoolExp deriving (Show, Eq)

eval :: BoolExp -> Bool
eval TRUE = True
eval FALSE = False
eval (IF con b1 b2) | eval con == True  = eval b1
                    | eval con == False = eval b2

eval' :: [BoolExp] -> Bool
eval' [TRUE] = True
eval' [FALSE] = False
eval' ((IF TRUE b1 b2):xs) = eval'(b1:xs)
eval' ((IF FALSE b1 b2):xs) = eval'(b2:xs)
eval' (l@(IF con b1 b2):xs) = eval'(con:l:xs)
eval' (TRUE:(IF con b1 b2):xs) = eval' (b1:xs)
eval' (FALSE:(IF con b1 b2):xs) = eval' (b2:xs)
-- test = IF (IF FALSE FALSE TRUE) (IF FALSE TRUE FALSE) FALSE
```

#### 参数化递归类型

预加载的库中定义了一个非常重要的类型，就是列表，它就是用了参数化与递归的方式定义的。

```haskell
>>> :i []
data [] a = [] | a : [a]        -- Defined in ‘GHC.Types’

{-
 定义一个列表
 列表要么为空列表，定义为Nil，那么时一个 a 类型的元素结合一个 a 类型的列表。这里，Nil 为递归定义的基本情况相当于列表定义中的 []，而 Cons a (List a)为递归定义。Cons 时一个数据的构造器，在这里相当于 (:) 运算符。List 时类型的名字，Nil 与 Cons 为构造器的函数。
-}
data List a = Nil | Cons a (List a) deriving (Eq, Show)

-- 既然定义List 和 Haskell 中定义的列表的形式时一样的他们时定价的，那么他们之间可以相互转换
myListToList Nil = []
myListToList (Cons x xs) = x : (myListToList xs)

listToMyList [] = Nil
listToMyList(x:xs) = Cons x (listToMyList xs)
```


## 类型的同构

在上面，定义的列表类型与 Haskell 中的列表类型功能是相同的。这里的相同其实就是指两个类型”等价“，这种等价称为**同构（isomorphism）**。如果两个类型 A 与 B 之间可以相互转换，也就是说我们可以定义出两个转换函数，并且这两个函数均为一一对应的函数且互为反函数，则可称类型 A 与 B是同构的。

**同构的类型**：对于两个类型 A 与 B，若可以定义 f :: A - > B 将 A映射到 B，并且可以定义 f 的反函数 g :: B -> A 将 B 映射到 A 且满足 f . g = idʙ 和 g . f = id𝘈 。（ **.** 为复合函数运算符，  id𝘈 与 idʙ 分别是 A 与 B 类型上的恒指映射），那么说类型 A 与 类型 B 为同构的  记做 A≃B 。

**同构映射**：对于类型 A 与 B，函数  f :: A - > B 为同构映射，若存在一个函数（称为逆（inverse）函数） g :: B -> A 满足：f . g = idʙ ， g . f = id𝘈 

```haskell
                          -- 同构类型示意图
						  | ←   g   ←    |
                    idA ↔︎ A               B ↔︎ idB
                          | →    f   →    |                  
```

任意类型都与自己同构，即 A≃A 。**即 ≃ 是自反的。(reflexive)**

如果 A 与 B 同构，那么 B 与 A 也同构，即 A≃B   =>  B≃A。**即 ≃ 是对称的。（synmetric）**

如果  A≃B  并且 B≃C，那么 A≃C ，即 A≃B  ^ B≃C  => A≃C。**即 ≃ 是传递的。(reflexive)**



List 和 Haskell 内置的列表[] 是同构的，两个类型同构则说明定义在 [] 中的函数在 List 中也可以定义。

```haskell
listHead :: List a -> a
listHead Nil = undefined
listHead (Cons x xs) = x
```

对于枚举类型，如果所枚举的值的个数是相等的。那么可以写两个函数相互转换并且能够满足同构的条件。

对于这种情况，可以**总结出更为一般的规则：给定两个使用枚举类型，若它们之中定义的值的个数相等，那么这两个类型是同构的。**

```haskell
data ThreeNum = One | Two | Three
data Level  = Low | Middle | High

f:: ThreeNum -> Level
f One = Low
f Two = Middle
f Three = High

g :: Level -> ThreeNum
g Low = One
g Middle = Two
g  High = Three
```
列表是一个参数化定义类型，若给定这个类型参数为 Unit，并且 Unit 类型中仅定义有一个值 —— Unit，那么可以看出， List Unit 与Nat 是同构的。并且我们定义的 Unit 与 Haskell 内置的 () 类型是同构的，即 () ≃ Unit

```haskell
data Unit = Unit deriving (Eq, Show)
data List a = Nil | Cons a (List a) deriving (Eq, Show)
data Nat = Zero | Succ Nat deriving (Eq, Show)

-- data List Unit = Nil | Cons Unit (List List)
-- data Nat = Zero | Succ Nat

-- 转换函数
list2Nat Nil = Zero
list2Nat (Cons x xs) = Succ (list2Nat xs)

nat2List Zero = Nil
nat2List (Succ n) = Cons Unit (nat2List n)

-- 所以，可以得到结论： List Unit ≃ Nat
```


下面介绍一下新类型的构建与更为一般的同构类型。若给定类型 A、B、C，那么下列给予它们的元祖显然也是同构的：

(A, B) ≃ (B, A)

((A, B), C) ≃ (A, (B, C)) ≃ (A,B,C)

函数类型之间也可以是同构的，只是此时对应的转换函数 f 与 g 均为高阶函数。

A -> (B, C) ≃ A -> (C, B)

(A, B) -> C ≃ A -> B -> C （使用ucrry 和 uncurry 转换函数）

**元祖类型**，只有一个构造器，构造器内含有多个类型，在书面表达式常常用 X 来表示，如二元元组可以定义为 data Pair A B = Pair A B。记作 A X B，称作 **积类型（product type）**，在集合中称为笛卡尔积（Cartesian product）。Pair A B 类型中值的个数是 A 与 B 类型的值的个数之积。可以用 |X| 类型的值的个数，那么，则有， |A X B| = |A| X |B|。

**Either类型**，由多个构造器（或称多模式（multi-pattern））枚举定义的类型，则用 + 来表示，比如 data Either A B = Left A | Right B，记作 A + B，称作**和类型（sum type）**，从集合的角度可以理解为不相交并集，即，在结合两个类型时，即便它们有重合的元素，但 Left 与 Right 构造器将作为标记对它们加以区分。如 Either Bool Bool 类型中有 Left True、Left False、Right True、Right False 这4个值，应该注意到 Left True 和 Right True 是不同的值，虽然它们来自于同一种类型。显然这个类型值的个数是 A 与 B 类型值的个数之和，那么，则有 |A + B| = |A| + |B|.

**函数类型**，如果是 data Fun = Fun (A -> B) 这样的函数类型，记作： Bᴬ，即这样的函数有 |B|ᴬ| = |Bᴬ|个。

像**布尔类型**这样以具体值或者称为**零元构造器**的 **“和” 类型有时称为累计类型（counting）**，如布尔类型可以写为 1 + 1，第一个 1 表示 False， 第二个 1 表示 True，可以看到他与 Either () () 同构。

```haskell
bool2EitherUnit :: Bool -> Either () ()
bool2EitherUnit False = Left ()
bool2EitherUnit True = Right ()

eitherUnit2Bool :: Either () () -> Bool
eitherUnit2Bool (Left ()) = False
eitherUnit2Bool (Right ()) = True
```

对于自然数的自定 data Nat = Zero | Succ Nat ，则写为 Nat = 1 + Nat，可以看在定义中使用到了 Nat 本身，因为这是一个递归类型。

**这样由 () 类型通过 和类型、积类型还有函数类型等等方式组合定义出来的类型称为 代数数据类型（Algebraic Data Type，简写为 ADT）。**

`data T = Con a1 a2 a3 a4 ... an` ，这里使用的多个参数与使用一个元组定义时等价的， T 的类型可记作 a1 × a2 × a3 × a4 × ... an，这个类型显然与 n 元元组是同构的。 

`data T = A a b c .. | B d e f .. | C g h i ..| ...`， 这里的 T 类型可以记作 (a × b × c ...) +  (d × e × f …) +  (g × h × i …) + …  。这样的类型也称为**一般化的结构类型**。



之前介绍的几个同构关系可以记作：

A × B ≃ B × A

(A × B) × C ≃ A × (B × C)

(B × C)ᴬ ≃ (C × B)ᴬ

C(ᴬ⨯ᴮ) ≃ (Cᴮ)ᴬ  （使用ucrry 和 uncurry 转换函数）

还缺少证明 TODO



此外，对于： A × (B × C) ≃ A × B + A × C

(A, Either B C) 和 Either (A, B) (A, C) 显然是同构的。

(A, Either B C)        				 为 A * (B + C)

Either (A, B) (A, C)  为 A * B +  A * C 等于 A * (B + C)

```haskell
f :: (a, Either b c) -> Either (a, b) (a, c)
f (a, Left b) = Left (a, b)
f(a, Right c) = Right (a, c)

g ::  Either (a, b) (a, c) -> (a, Either b c)
g (Left (a, b)) = (a, Left b)
g (Right (a, c)) = (a, Right c)
```
这样，使用 **模式匹配** 或者 **case** 来定义基于某一类型的函数式，每一条匹配实际上匹配的是该**和类型**的某一个变体，即某一个构造器与该构造器的参数，这个参数可能是一个 **积** **或者一个参数**。而需要对一个参数进行多个模式匹配则是因为该类型是通过多个数据构造器的和定义的，也就是因为这个类型有多个变体，多种模式。

Either 的定义和模式匹配如下：

```haskell
data Either a b = Left a | Right b
f (Left a)  = ...
f (Right b) = ...
```

可以看到 Either 类型有两个变体或者说两种模式 Left 与Right，所以有两条匹配，而每条匹配都会得到构造器中的参数。同时，读者也应该意识到 Non-exhaustive patterns 异常的原因了，即在定义函数时，没有把所有的数据形式都考虑进来。也就是说，有一些形式在我们的函数种没有被定义，但是调用函数时出现了这种形式没有匹配。**在编译的过程中，GHC 会对这些遗漏给出一些警告，即便定义时确定不会出现这种形式，也最好通过 error 或者其它方式来定义不上这个缺口。**

```haskell
-- 使用值构造器 :  做模式匹配
get4 (_:_:_:x:_) = x
get4 _ = error "error param"

-- 可以使用 NPlusKPatterns 语言扩展 (n + 1)方式的模式匹配，不推荐使用
{-# LANGUAGE  NPlusKPatterns #-}
data Nat = Zero | Succ Nat deriving (Show, Eq, Ord)
int2nat :: Int -> Nat
int2nat 0 = Zero
-- int2nat n = Succ $ int2nat (n - 1)
int2nat (n + 1) = Succ $ int2nat n 
```
## 多条件分支、模式匹配守卫、观察模式表达式与模式的别名

本节的内容主要是解决了一些我们在使用 Haskell 编程中遇到的痛点，基本全属于 语法糖。

### 多分支条件表达式

首先在文件首处声明 **MultiWayIf** 编译器扩展，然后再定义函数。

```haskell
{-# LANGUAGE MultiWayIf  #-}

-- 这里的表达式与 缩进 有关
test score = if | score > 60 -> if | score == 100 -> "A"
                                   | score >= 90  -> "B"
                                   | score >= 70  -> "C"
                                   | otherwise    -> "D"
                | score > 50 -> "E"
                | otherwise  -> "F"

-- 如果想转成缩进无关的代码可以使用花括号 {} 来指明每个分支所在的范围
{-# LANGUAGE MultiWayIf  #-}
test score = if {| score > 60 ->
                    if {| score == 100 -> "A" | score >= 90  -> "B" | score >= 70  -> "C" | otherwise -> "D"}
       | score > 50 -> "E"
       | otherwise  -> "F"}
```
### 模式匹配守卫表达式

首先在文件首处声明 **PatternGuards** 编译器扩展，然后再定义函数。

```haskell
{-# LANGUAGE PatternGuards  #-}

-- Triangle 三角形
data Shape = Triangle Int Int Int | Circle Int

isValidShape :: Shape -> Bool
isValidShape s | Circle r       <- s, r > 0 = True
isValidShape s | Triangle a b c <- s, c > 0 && c > 0 && c > 0 &&
                                      a + b > c && a + c > b && b + c > a
                                      = True
isValidShape _ = False

-- 另一种写法
isValidShape :: Shape -> Bool
isValidShape (Circle r)       | r > 0 = True
isValidShape (Triangle a b c) | c > 0 && c > 0 && c > 0 && a + b > c && a + c > b && b + c > a = True
isValidShape _ = False
```

模式匹配守卫表达式还可以匹配多种类型

```haskell
-- {-# LANGUAGE PatternGuards  #-}

-- Triangle 三角形
data Shape = Triangle Int Int Int | Circle Int

isValidShape :: Maybe Bool -> Shape -> Bool
isValidShape m s | Just x <- m, Circle r       <- s, r > 0 = x && True
isValidShape m s | Just x <- m, Triangle a b c <- s, c > 0 && c > 0 && c > 0 &&
                                      a + b > c && a + c > b && b + c > a
                                      = x && True
isValidShape _ _ = False
```

### 观察模式表达式

首先在文件首处声明 **ViewPatterns** 编译器扩展，然后再定义函数。

```haskell
{-# LANGUAGE ViewPatterns  #-}

import Data.Sequence

one2ten :: Seq Int
one2ten = fromList [1..10]

-- 使用 case 的 情况模式表达式
match :: Seq Int -> Seq Int -> (Int, Seq Int)
match s1 s2 = case viewl s1 of
                   EmptyL -> case viewr s2 of
                                  EmptyR -> (0, s2)
                                  xs :> x -> (x, xs)
                   a :< as -> case viewr s2 of
                                  EmptyR -> (a, as)
                                  xs :> x -> (a + x, xs >< as)

-- 使用 观察模式表达式
-- 观察模式匹配中 -> 左侧的是观察函数，它是需要一个参数得到结果，需要把模式写在肩头的右侧
match' :: Seq Int -> Seq Int -> (Int, Seq Int)
match' (viewl -> EmptyL) s2@(viewr -> EmptyR) = (0, s2)
match' (viewl -> EmptyL) (viewr -> xs :> x)   = (x, xs)
match' (viewl -> a :< as) (viewr -> EmptyR)   = (a, as)
match' (viewl -> a :< as) (viewr -> xs :> x)  = (a + x, xs >< as)

>>> match empty empty 
(0,fromList [])

>>> match empty one2ten  
(10,fromList [1,2,3,4,5,6,7,8,9])

>>> match one2ten empty   
(1,fromList [2,3,4,5,6,7,8,9,10])

>>> match one2ten (fromList [100..110])
(111,fromList [100,101,102,103,104,105,106,107,108,109,2,3,4,5,6,7,8,9,10])
```
### 模式的别名

首先在文件首处声明 **PatternSynonyms** 编译器扩展，然后再定义函数。

```haskell
{-# LANGUAGE PatternSynonyms #-}

data Exp = Val Int | Exp String [Exp]
pattern Add t1 t2 = Exp "+" [t1, t2]
pattern Sub t1 t2 = Exp "-" [t1, t2]

eval (Val n) = n
eval (Add t1 t2) = eval t1 + eval t2
eval (Sub t1 t2) = eval t1 - eval t2

>>> eval (Add (Val 100) (Val 200))
300
>>> eval (Sub (Val 100) (Val 200))
-100
```

如果开启了 **PatternSynonyms** 就无法定义名为 pattern 的函数了。