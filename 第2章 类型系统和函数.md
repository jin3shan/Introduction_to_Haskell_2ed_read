## Haskell 常用数据类型

- 布尔型：**Bool**，只有True 与 False 两个值。Haskell中约定类型的名称与该类型的数据（类型构造器）的首字母要大写（数字类型除外）。&& 表示“逻辑与”运算，||表示“逻辑或“运算，not表示“逻辑非“运算。
- 字符型：**Char**。
- 有符号整数：**Int**。2^64::Int 表示 2的64次方，::Int的意思是要求编译器把2^64作为整数处理。因为Haskell里还有另外一个整数类型——任意精度整数。
- 无符号整数：**Word**。~~使用Word类型需要导入Data.word库。~~可以使用:m +Data.word来控制模块的加载。
- 任意精度整数：**Integer**。表示任意大小的整数，限制它的大小范围唯一的因素就是计算机内存。
  - 除了Int、Word与Integer外，在Data.Int模块中，Haskell还支持Int8、Int16、Int32、Int64、Word8、Word16、Word32、Word64等。
  - Haskell中除了十进制外，还可以用二进制、八进制、十六进制来表示整数。在表示时需要在数值前分别加上**0b、0O、0x等前缀**来表示。在GHCi中使用二进制数值需要使用 **:set -XBinaryLiterals** 进行设置；在代码文件中使用二进制数值就需要在文件首次加上 **{-# LANGUAGE  BinaryLiterals #-}**，这就是语法标准以外的特性。
- 小数与有理数：Float、Double、Rational。Rational，即用两个任意精度的整数来表示一个小数。3.1415 :: Rational 会转换成 6283 % 2000，%相当于分数线，6283为分母，2000为分子，这样，一个小数就被转换为了分数。
- 字符串类型：**String**。在Haskell里，String实际时其它类型的别名，String的类型定义为[Char]，也就是说String时一个Char的列表。
- **元组类型**。需要一个数对来表示一些数据。元组的数称为该元组的元件（component）。元组可以时二元元组，还可以时多元元组。一旦确定了元组中元件的个数，就不可以像列表那样伸缩了。同时，每一个元件的类型也不能改变。对于二元元组而言有两个重要的函数，它们时fst与snd，它们会返回元组里的第一个元件和第二个元件。 如 fst (5, True)，Haskell中最多支持62个元素的元组。



## 函数类型

函数可以理解为从参数到结果的一个映射，比如T1 -> T2。

- **非柯里化函数**：当函数有多个参数时，必须通过元组一次性传入，然后返回结果，这样的函数就是非柯里化的函数。

- **柯里化函数**：当函数有多个参数时，参数可以一个一个地一次输入，如果参数不足，将返回一个函数作为结果，这样的函数就是柯里化函数。Prelude定义了curry与uncurry两个函数，用于柯里化和非柯里化的转换。

- **多态函数**：一个函数的某个参数可以是任何类型的值，那么这个函数就是多态函数(polymorphic function)。
- **重载类型函数**：=>是类型类的限定符号。
  - 重载的字面值（overloaded literals）：可以有着多种类型的字面值称为重载的字面值，即一个字面值可以有多种类型。
  - 像abs这样的函数就是重载函数，它的参数a受到一个名为Num的类型类的限定，并且在声明时把类型类限定写在类型签名中=>的左侧，有时我们说这里的a是一个**受类型类限定的（多态）类型**。也有一些文章中称为{**特定的多态**}（ad），是因为这些类型只能变化成其他某些特定类型的原因。
  - **重载函数**：重载函数的意思是同一个名字的函数可以**根据类型或者参数数量的不同有不同的实现**。
  - Haskell中的重载函数主要是针对不同的参数类型进行重载，而没有根据参数的数量进行重载。
  - **类型类**就是Haskell进行函数重载的重要手段。
  - 在Haskell中，函数或运算符的定义是唯一的，不可以出现第二种不同的定义，也就是说，对于每个函数，它的型只有一种，如果需要重载就需要借助类型类。
  - 在Java中，不但参数的类型可以不同，就连参数的个数也可以不同。Java中可以这样做是因为在调用函数时必须给出全部的参数。如果读者回顾之前的内容就会知道，Java中的函数是非柯里化的函数。而在Haskell中，可以给出部分参数，而以函数作为返回的结果，这使得Haskell不能像Java一样对函数直接进行重载，但是借助类型类我们也可以做类似的事情。
  - Haskell中的`print`函数是使不同的类型实现`Show`类型类来实现这种重载的功能的，`print`函数的类型为`Show a => a -> IO ()`。对于所有的实现为`Show`类型类实例的类型都可以使用`print`函数输出在命令行上。

## 类型别名

在Hashell中，可以用`type`关键字将类型替换称为其它的名字，在定义时类型的名称要**以大写字母开头**。例如：

`type RGB = (Int, Int, Int)`

这样，Haskell就会将RGB类型自动替换`(Int, Int, Int)`。

`type`关键字只能做一些替换。在定义类型的别名时，它只是将已经有的数据类型组合成一个新的数据类型，并不能构造出新的数据类型。

## 类型的重要性

- 错误检查
- 对于程序的抽象
- 文档作用

## Haskell中的类型类

Haskell给很多“类型”分成了“类型类”，归为一类的类型有着共同的属性，不同类型所归的类就称为类型类。类型有着某种属性，意为该类型可以实现特定的函数，类型通过实现类型类中声明的函数来称为其中的一份子。

查看类型时，`:t (==)`、`:t (<)`等类型需要添加**左括号"("和右括号")"**。

- **相等类型类：Eq**，`==`判定两个值是否相等，`/=`判定两个值是否不相等。
- **有序类型类：Ord**，有序类型类囊括的是可以比较大小的类型。Haskell中规定：一个有序类型一定是一个可比较相等的类型。也就是说，Ord基于Eq的。那么可以比较大小的类型一定可以判定该类型的连个值是否相等，正是这一原因我们才能够使用<=、>=等关系运算符。Char类型、String类型都是有序的。这里，由于Char类型是有序的，因此基于Char类型的列表[Char]，即String是有序的，同样地，数字的列表也是有序的。
- **枚举类型类：Enum**，有一些类型可以按一定的顺序枚举。只要给定范围，Haskell就可以一个一个地对这个类型的数据进行枚举。 例如`[1..10]`、`['a'..'z']`枚举。除使用`..`以外，一个类型如果实现了枚举类型类，那么给定一个元素（若这个元素不是最后一个）总是可以使用枚举类型类中的`succ`函数得到下一个元素。同样地，如果给定一个元素，若这个元素不是第一个，则总是可以使用`pred`函数得到它的第一个值。
- **有界类型类：Bounded**，可以枚举定义的数据往往是有界的。比如，Bool，Int等都是有最大值和最小值的。布尔类型中只有两个值，一个是`True`，它是布尔类型中的最大值，另一个是`False`，它是布尔类型中的最小值。使用 `maxBound :: Bool` 和 `minBound :: Bool`，分别查看最大值和最小值。
- **数字类型类：Num**
  - 固定长度的Word和Int类型分别定义在Data.Word与Data.Int中。
  - 复数类型Complex和比值类型Ratio分别定义在Data.Complex与Data.Ration中。
  - 使用复数类型，`:m +Data.Complex`，`(5:+5) + (1:+1)` 和 `sin (5:+5)` 等。
  - Float与Double两个小数实际类型是Enum类型类，这并不代表可以像遍历整数那样遍历所有小数，而只是可以以固定的差值来便利。例如`[1.0,1.5..3.0]`  推断出 `[1.0,1.5,2.0,2.5,3.0]`。而`succ` 与`pred` 默认长度是1。
  - **数字类型转换函数**。
    - `truncate`函数可以将一个小数的整数部分取出。例如 `truncate 3.14`   结果为 `3`。
    - properFraction函数可以将一个小数的两部分分成整数与小数部分以一个元组换回。例如 `properFraction 3.14` 结果为 `(3,0.14000000000000012)`。
    - `floor` 向下取整。
    - `ceiling` 向上取整数。
    - `round` 四舍五入取整。
  - **固定精度小数**计算，Data.Fixed模块。
    - div'函数用于取余。
    - mod' 函数用于取模。
    - divMod'函数用于取余取模。返回取余和取模的元组。
    - 其它精度类型。
  - **NaN与无穷大**
    - NaN是非数字（not a number）的缩写。 `0 / 0`  结果为 NaN。这个值非常特殊，IEEE标准中规定它与任何值都不相等，包括NaN自身。`0/0 == 0/0` 结果为 `False`。如果需要判定一个值是不是NaN可以使用RealFloat类型类中定义的isNaN函数。
    - 无穷又分为正无穷和负无穷，分别为 `Infinity` 与 `-Infinity`。`-1 / 0` 结果为 `-Infinity`， `1 / 0` 结果为 `Infinity`。可以通过RealFloat类型类中定义的`isInfinity`函数来判定一个值是不是无穷。
    - 在RealFloat类型类中并没有定义这两个值，我们也无法直接使用 `Infinity` 与 `-Infinity`。
    - 在**Numeric.IEEE模块**基于RealFloat类型类定义IEEE类型类，其中就包含了infinity 与 nan 两个特殊值。使用 `cabal install ieee754` 安装 ieee754 库。
- **可显示类型类：Show**，比值`Ratio`类型输出两个整数，两个整数之间用`%`分开，复数`Complex`类型输出两个小数，中间用`:+`分开。通过 `Text.Show.Functions`模块可以显示函数。`:m +Text.Show.Functions` `show(+)` 结果为 `"<function>"`

## 小结

**类型**是通过`data`关键字来定义的。

**类型类**是通过`class`关键字来定义的。

**Haskell中的类型类和Java中的接口有些相像**。类型类中定义了一些函数，如果定义了一个新的类型，只要这个类型实现了类型类中声明函数，这个类型就属于该类型类了。

## Haskell中的函数

- **Haskell中的值**
  - Haskell里的变量的值在绑定后不会改变，所有变量一定意义上可以理解为定值。
  - Haskell值与函数统一的，即函数也是一种值。函数只会需要其它参数输入的值。
  - 如果定义的是函数，那么这个函数的行为在运行过程中也是不会改变的，对于某一个特定的输入返回的结果总是确定的，这样的函数为**纯函数**。
- **函数思想入门**
  - 函数是从参数到结果的一个映射。 T - > S （T、S 可以是任何类型，包括函数）。
  - 在Haskell的世界里，所有的运算符号都可以被看做是函数。例如 `(+)  1 2` 结果为 3，这种写法只是将中缀运算符置前。
  - 执行 `:t (+)` 类型结果为 `(+) :: Num a => a -> a -> a` ，`->` 是向右结合的符号，所有类型`(Num a) => a -> a -> a`指的是 `Num a => a -> (a -> a)` 。这是一个柯里化的函数。当执行 `:t (+) 1` 后，这时就送一个函数得到了另一个函数`(+) 1 :: Num a => a -> a`。
  - 在Haskell中，当给定第一个参数应用于一个n元函数，返回的结果是一个n-1元函数。那些没有给出所有参数的函数应用称为**函数的不完全应用**（partial application，有时译为**偏函数应用**）
  - 以函数作为输入的函数或者以函数作为返回结果的函数，称之为**高阶函数**。
- **函数的基本定义格式**
  - 一般情况下，先要在第一行定义函数名与函数的类型，它称为**类型签名**（type signature）。定义类型签名后，另起一行写出函数名、参数，最后定义函数体。
    - 函数名 :: 参数1 的类型 -> 参数2 的类型 -> 参数n 的类型 -> 结果类型
    - 函数名 参数1 参数2 … = 函数体
  - `::`执行函数的类型。
  - Haskell 有类型推断系统，它可以自动推断出一个函数的类型。
  - 但是，如果定义函数时可以给定该函数的类型，那么Haskell的类型推断系统会检查系统得出的类型与我们给定的类型是否一致，这在一定程度上可以保证函数的正确性。
  - `::`可以指定类型，但具有相同类型也可以合并在一起，函数名之间用逗号分隔。
    - `add, sub :: Int -> Int -> Int`
    - `add a b = a + b`
    - `sub a b = a - b`
  - 当有多个类型类限定在一个类型上的时候，它们需要用括号写在一起，并且中间要用逗号隔开。
    - `function :: (Show a, Ord a) => a - a - a`
    - ~~function :: Show a => Ord a => a -> a -> a~~ (非Haskell98 标准)
  - .hs文件的全局函数的名必须要从美航最前端开始写。
  - 函数名不能以大写的英文字母和数字开头，因为大写开头的字母单词是被当成类型或者类型数据使用的。比如 Bool 类型，True 与 False。
  - 多元函数
  - `f :: Num a => (a, a) -> a`
  - `f (x , y) = x + y`  多元函数，同时也是非柯里化函数， 这样的函数以一个**元组**即一个实数对作为输入。
  - `f :: Num a => a -> a -> a`
  - `f' x y = x + y` 柯里化函数

## λ表达式

Haskell还有另外一种书写函数的格式，与函数的类型相互对应，这就是λ表达式。

在代码编译后，函数最终都将会被化为λ表达式。参数一次输入的时候，在Haskell中可以省去参数间的箭头而简写成：

`f, f', f'' :: (Foldable t1, Foldable t) => t1 a1 -> t a -> Int`
`f lst1 lst2 = (length lst1) + (length lst2)`
`f' = \lst1 -> \lst2 -> (length lst1) + (length lst2)`
`f'' = \lst1 lst2 -> (length lst1) + (length lst2)`

- **α替换**：是指在不出现命名冲突的前提上可以将函数的参数重新命名。
- **β化简(λ规约)**(*λ化简?*)：是指参数到函数体的替换。
- **η化简**(η规约)：可以用来小区那些冗余的λ表达。*η中文读音为：艾塔或者伊塔。*
- λ表达式的应用
  - 构造一个没有名字的函数，**匿名函数**(anonymous function)。
  - 对于柯里化函数，在不给定前一个参数的前提下给定后一个。
- 参数的绑定
  - 在函数中，某个值仅需定义一次，这种情况可以用`let .. in`。

  - ```
    s :: Double -> Double -> Double -> Double
    s a b c = let p = (a + b + c) / 2 
              in sqrt (p * (p - a) * (p - b) * (p - c))
    ```

  - `let .. in` 还可以绑定函数，let f x = x + 1 in f 5 结果为6。

  - 多个表达式绑定可以用分号隔开， `let x = 2; y = 2 in x + y`。

    - `f a b = let p = (a * 10); q = (b * 10) in p + q`

  - 除了用 let .. in 以外，还可以使用**where**。可以先定义好函数，然后再where关键字后边定义参数作为函数定义的补充。

  - ```
    s' :: Double -> Double -> Double -> Double
    s' a b c = sqrt (p * (p - a) * (p - b) * (p - c))
                where 
                    p = (a + b + c) / 2
    ```

  - 使用 `let .. in`，绑定要注意命名捕获（name ccapture)，比如：

  - `let x = 6 in x *  let x = 2 in x * x`，第一个x的值是6，后两个x的值是2，即 6 * 2 * 2 =24。

  - 但是，如果定义一个函数，用了**where**绑定，那么它在函数的全部范围都是有效的。

