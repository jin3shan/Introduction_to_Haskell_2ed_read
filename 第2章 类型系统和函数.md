## Haskell 常用数据类型

- 布尔型：**Bool**，只有True 与 False 两个值。Haskell中约定类型的名称与该类型的数据（类型构造器）的首字母要大写（数字类型除外）。&& 表示“逻辑与”运算，||表示“逻辑或“运算，not表示“逻辑非“运算。
- 字符型：**Char**。
- 有符号整数：**Int**。2^64::Int 表示 2的64次方，::Int的意思是要求编译器把2^64作为整数处理。因为Haskell里还有另外一个整数类型——任意精度整数。
- 无符号整数：**Word**。~~使用Word类型需要导入Data.word库。~~可以使用:m +Data.word来控制模块的加载。
- 任意精度整数：**Integer**。表示任意大小的整数，限制它的大小范围唯一的因素就是计算机内存。
  - 除了Int、Word与Integer外，在Data.Int模块中，Haskell还支持Int8、Int16、Int32、Int64、Word8、Word16、Word32、Word64等。
  - Haskell中除了十进制外，还可以用二进制、八进制、十六进制来表示整数。在表示时需要在数值前分别加上**0b、0O、0x等前缀**来表示。在GHCi中使用二进制数值需要使用 **:set -XBinaryLiterals** 进行设置；在代码文件中使用二进制数值就需要在文件首次加上 **{-# LANGUAGE  BinaryLiterals #-}**，这就是语法标准以外的特性。
- 小数与有理数：Float、Double、Rational。Rational，即用两个任意精度的整数来表示一个小数。3.1415 :: Rational 会转换成 6283 % 2000，%相当于分数线，6283为分母，2000为分子，这样，一个小数就被转换为了分数。
- 字符串类型：**String**。在Haskell里，String实际时其它类型的别名，String的类型定义为[Char]，也就是说String时一个Char的列表。
- **元组类型**。需要一个数对来表示一些数据。元组的数称为该元组的元件（component）。元组可以是二元元组，还可以时多元元组。一旦确定了元组中元件的个数，就不可以像列表那样伸缩了。同时，每一个元件的类型也不能改变。对于二元元组而言有两个重要的函数，它们时fst与snd，它们会返回元组里的第一个元件和第二个元件。 如 fst (5, True)，Haskell中最多支持62个元素的元组。



## 函数类型

函数可以理解为从参数到结果的一个映射，比如T1 -> T2。

- **非柯里化函数**：当函数有多个参数时，必须通过元组一次性传入，然后返回结果，这样的函数就是非柯里化的函数。

- **柯里化函数**：当函数有多个参数时，参数可以一个一个地一次输入，如果参数不足，将返回一个函数作为结果，这样的函数就是柯里化函数。Prelude定义了curry与uncurry两个函数，用于柯里化和非柯里化的转换。

- **多态函数**：一个函数的某个参数可以是任何类型的值，那么这个函数就是多态函数(polymorphic function)。
- **重载类型函数**：=>是类型类的限定符号。
  - 重载的字面值（overloaded literals）：可以有着多种类型的字面值称为重载的字面值，即一个字面值可以有多种类型。
  - 像abs这样的函数就是重载函数，它的参数a受到一个名为Num的类型类的限定，并且在声明时把类型类限定写在类型签名中=>的左侧，有时我们说这里的a是一个**受类型类限定的（多态）类型**。也有一些文章中称为{**特定的多态**}（ad），是因为这些类型只能变化成其他某些特定类型的原因。
  - **重载函数**：重载函数的意思是同一个名字的函数可以**根据类型或者参数数量的不同有不同的实现**。
  - Haskell中的重载函数主要是针对不同的参数类型进行重载，而没有根据参数的数量进行重载。
  - **类型类**就是Haskell进行函数重载的重要手段。
  - 在Haskell中，函数或运算符的定义是唯一的，不可以出现第二种不同的定义，也就是说，对于每个函数，它的型只有一种，如果需要重载就需要借助类型类。
  - 在Java中，不但参数的类型可以不同，就连参数的个数也可以不同。Java中可以这样做是因为在调用函数时必须给出全部的参数。如果读者回顾之前的内容就会知道，Java中的函数是非柯里化的函数。而在Haskell中，可以给出部分参数，而以函数作为返回的结果，这使得Haskell不能像Java一样对函数直接进行重载，但是借助类型类我们也可以做类似的事情。
  - Haskell中的`print`函数是使不同的类型实现`Show`类型类来实现这种重载的功能的，`print`函数的类型为`Show a => a -> IO ()`。对于所有的实现为`Show`类型类实例的类型都可以使用`print`函数输出在命令行上。

## 类型别名

在Hashell中，可以用`type`关键字将类型替换称为其它的名字，在定义时类型的名称要**以大写字母开头**。例如：

`type RGB = (Int, Int, Int)`

这样，Haskell就会将RGB类型自动替换`(Int, Int, Int)`。

`type`关键字只能做一些替换。在定义类型的别名时，它只是将已经有的数据类型组合成一个新的数据类型，并不能构造出新的数据类型。

## 类型的重要性

- 错误检查
- 对于程序的抽象
- 文档作用

## Haskell中的类型类

Haskell给很多“类型”分成了“类型类”，归为一类的类型有着共同的属性，不同类型所归的类就称为类型类。类型有着某种属性，意为该类型可以实现特定的函数，类型通过实现类型类中声明的函数来成为其中的一份子。

查看类型时，`:t (==)`、`:t (<)`等类型需要添加**左括号"("和右括号")"**。

- **相等类型类：Eq**，`==`判定两个值是否相等，`/=`判定两个值是否不相等。
- **有序类型类：Ord**，有序类型类囊括的是可以比较大小的类型。Haskell中规定：一个有序类型一定是一个可比较相等的类型。也就是说，Ord基于Eq的。那么可以比较大小的类型一定可以判定该类型的连个值是否相等，正是这一原因我们才能够使用<=、>=等关系运算符。Char类型、String类型都是有序的。这里，由于Char类型是有序的，因此基于Char类型的列表[Char]，即String是有序的，同样地，数字的列表也是有序的。
- **枚举类型类：Enum**，有一些类型可以按一定的顺序枚举。只要给定范围，Haskell就可以一个一个地对这个类型的数据进行枚举。 例如`[1..10]`、`['a'..'z']`枚举。除使用`..`以外，一个类型如果实现了枚举类型类，那么给定一个元素（若这个元素不是最后一个）总是可以使用枚举类型类中的`succ`函数得到下一个元素。同样地，如果给定一个元素，若这个元素不是第一个，则总是可以使用`pred`函数得到它的第一个值。
- **有界类型类：Bounded**，可以枚举定义的数据往往是有界的。比如，Bool，Int等都是有最大值和最小值的。布尔类型中只有两个值，一个是`True`，它是布尔类型中的最大值，另一个是`False`，它是布尔类型中的最小值。使用 `maxBound :: Bool` 和 `minBound :: Bool`，分别查看最大值和最小值。
- **数字类型类：Num**
  - 固定长度的Word和Int类型分别定义在Data.Word与Data.Int中。
  - 复数类型Complex和比值类型Ratio分别定义在Data.Complex与Data.Ration中。
  - 使用复数类型，`:m +Data.Complex`，`(5:+5) + (1:+1)` 和 `sin (5:+5)` 等。
  - Float与Double两个小数实际类型是Enum类型类，这并不代表可以像遍历整数那样遍历所有小数，而只是可以以固定的差值来便利。例如`[1.0,1.5..3.0]`  推断出 `[1.0,1.5,2.0,2.5,3.0]`。而`succ` 与`pred` 默认长度是1。
  - **数字类型转换函数**。
    - `truncate`函数可以将一个小数的整数部分取出。例如 `truncate 3.14`   结果为 `3`。
    - properFraction函数可以将一个小数的两部分分成整数与小数部分以一个元组换回。例如 `properFraction 3.14` 结果为 `(3,0.14000000000000012)`。
    - `floor` 向下取整。
    - `ceiling` 向上取整数。
    - `round` 四舍五入取整。
  - **固定精度小数**计算，Data.Fixed模块。
    - div'函数用于取余。
    - mod' 函数用于取模。
    - divMod'函数用于取余取模。返回取余和取模的元组。
    - 其它精度类型。
  - **NaN与无穷大**
    - NaN是非数字（not a number）的缩写。 `0 / 0`  结果为 NaN。这个值非常特殊，IEEE标准中规定它与任何值都不相等，包括NaN自身。`0/0 == 0/0` 结果为 `False`。如果需要判定一个值是不是NaN可以使用RealFloat类型类中定义的isNaN函数。
    - 无穷又分为正无穷和负无穷，分别为 `Infinity` 与 `-Infinity`。`-1 / 0` 结果为 `-Infinity`， `1 / 0` 结果为 `Infinity`。可以通过RealFloat类型类中定义的`isInfinity`函数来判定一个值是不是无穷。
    - 在RealFloat类型类中并没有定义这两个值，我们也无法直接使用 `Infinity` 与 `-Infinity`。
    - 在**Numeric.IEEE模块**基于RealFloat类型类定义IEEE类型类，其中就包含了infinity 与 nan 两个特殊值。使用 `cabal install ieee754` 安装 ieee754 库。
- **可显示类型类：Show**，比值`Ratio`类型输出两个整数，两个整数之间用`%`分开，复数`Complex`类型输出两个小数，中间用`:+`分开。通过 `Text.Show.Functions`模块可以显示函数。`:m +Text.Show.Functions` `show(+)` 结果为 `"<function>"`

## 小结

**类型**是通过`data`关键字来定义的。

**类型类**是通过`class`关键字来定义的。

**Haskell中的类型类和Java中的接口有些相像**。类型类中定义了一些函数，如果定义了一个新的类型，只要这个类型实现了类型类中声明函数，这个类型就属于该类型类了。

## Haskell中的函数

- **Haskell中的值**
  - Haskell里的变量的值在绑定后不会改变，所有变量一定意义上可以理解为定值。
  - Haskell值与函数统一的，即函数也是一种值。函数只会需要其它参数输入的值。
  - 如果定义的是函数，那么这个函数的行为在运行过程中也是不会改变的，对于某一个特定的输入返回的结果总是确定的，这样的函数为**纯函数**。
- **函数思想入门**
  - 函数是从参数到结果的一个映射。 T - > S （T、S 可以是任何类型，包括函数）。
  - 在Haskell的世界里，所有的运算符号都可以被看做是函数。例如 `(+)  1 2` 结果为 3，这种写法只是将中缀运算符置前。
  - 执行 `:t (+)` 类型结果为 `(+) :: Num a => a -> a -> a` ，`->` 是向右结合的符号，所有类型`(Num a) => a -> a -> a`指的是 `Num a => a -> (a -> a)` 。这是一个柯里化的函数。当执行 `:t (+) 1` 后，这时就送一个函数得到了另一个函数`(+) 1 :: Num a => a -> a`。
  - 在Haskell中，当给定第一个参数应用于一个n元函数，返回的结果是一个n-1元函数。那些没有给出所有参数的函数应用称为**函数的不完全应用**（partial application，有时译为**偏函数应用**）
  - 以函数作为输入的函数或者以函数作为返回结果的函数，称之为**高阶函数**。
- **函数的基本定义格式**
  - 一般情况下，先要在第一行定义函数名与函数的类型，它称为**类型签名**（type signature）。定义类型签名后，另起一行写出函数名、参数，最后定义函数体。
    - 函数名 :: 参数1 的类型 -> 参数2 的类型 -> 参数n 的类型 -> 结果类型
    - 函数名 参数1 参数2 … = 函数体
  - `::`执行函数的类型。
  - Haskell 有类型推断系统，它可以自动推断出一个函数的类型。
  - 但是，如果定义函数时可以给定该函数的类型，那么Haskell的类型推断系统会检查系统得出的类型与我们给定的类型是否一致，这在一定程度上可以保证函数的正确性。
  - `::`可以指定类型，但具有相同类型也可以合并在一起，函数名之间用逗号分隔。
    - `add, sub :: Int -> Int -> Int`
    - `add a b = a + b`
    - `sub a b = a - b`
  - 当有多个类型类限定在一个类型上的时候，它们需要用括号写在一起，并且中间要用逗号隔开。
    - `function :: (Show a, Ord a) => a - a - a`
    - ~~function :: Show a => Ord a => a -> a -> a~~ (非Haskell98 标准)
  - .hs文件的全局函数的名必须要从美航最前端开始写。
  - 函数名不能以大写的英文字母和数字开头，因为大写开头的字母单词是被当成类型或者类型数据使用的。比如 Bool 类型，True 与 False。
  - 多元函数
  - `f :: Num a => (a, a) -> a`
  - `f (x , y) = x + y`  多元函数，同时也是非柯里化函数， 这样的函数以一个**元组**即一个实数对作为输入。
  - `f :: Num a => a -> a -> a`
  - `f' x y = x + y` 柯里化函数

## λ表达式

Haskell还有另外一种书写函数的格式，与函数的类型相互对应，这就是λ表达式。

在代码编译后，函数最终都将会被化为λ表达式。参数一次输入的时候，在Haskell中可以省去参数间的箭头而简写成：

`f, f', f'' :: (Foldable t1, Foldable t) => t1 a1 -> t a -> Int`
`f lst1 lst2 = (length lst1) + (length lst2)`
`f' = \lst1 -> \lst2 -> (length lst1) + (length lst2)`
`f'' = \lst1 lst2 -> (length lst1) + (length lst2)`

- **α替换**：是指在不出现命名冲突的前提上可以将函数的参数重新命名。
- **β化简(λ规约)**(*λ化简?*)：是指参数到函数体的替换。
- **η化简**(η规约)：可以用来小区那些冗余的λ表达。*η中文读音为：艾塔或者伊塔。*
- λ表达式的应用
  - 构造一个没有名字的函数，**匿名函数**(anonymous function)。
  - 对于柯里化函数，在不给定前一个参数的前提下给定后一个。
- 参数的绑定
  - 在函数中，某个值仅需定义一次，这种情况可以用`let .. in`。

  - ```
    s :: Double -> Double -> Double -> Double
    s a b c = let p = (a + b + c) / 2 
              in sqrt (p * (p - a) * (p - b) * (p - c))
    ```

  - `let .. in` 还可以绑定函数，let f x = x + 1 in f 5 结果为6。

  - 多个表达式绑定可以用分号隔开， `let x = 2; y = 2 in x + y`。

    - `f a b = let p = (a * 10); q = (b * 10) in p + q`

  - 除了用 let .. in 以外，还可以使用**where**。可以先定义好函数，然后再where关键字后边定义参数作为函数定义的补充。

  - ```
    s' :: Double -> Double -> Double -> Double
    s' a b c = sqrt (p * (p - a) * (p - b) * (p - c))
                where 
                    p = (a + b + c) / 2
    ```

  - 使用 `let .. in`，绑定要注意命名捕获（name ccapture)，比如：

  - `let x = 6 in x *  let x = 2 in x * x`，第一个x的值是6，后两个x的值是2，即 6 * 2 * 2 =24。

  - 但是，如果定义一个函数，用了**where**绑定，那么它在函数的全部范围都是有效的。


## Haskell中的表达式

- **条件表达式**

  - Haskell里的 `if .. then .. else ..` 和顺序式编程语言有些不同，就是 else 后的条件表达式不可以省略，并且返回的类型必须相同
  - Haskell 中的`if .. then .. else ..` 可以理解为一个运算符（或者一个函数）。它是一个混合为止运算符。(mixfix operator 或者译为混缀运算符)。

- **情况分析表达式**

  - 情形分析表达式是用 **case** 与 **of** 关键字来对一个类型中不同的值进行讨论的。它与顺序式编程里的 switch ..case 类似。区别就是，Haskell不用像switch那样选择一个条件继续向下运行而不自动跳出。因此，在Haskell中，不需要用到break关键字。顺序式语言中的 default 关键字和Haskell里的通配符类似，即一个下划线"_"，表示除了上面匹配外，匹配所有的值。例如：

  - ```
    month :: Int -> Int
    month n = case n of
      1 -> 31
      2 –> 28
      ...
      9  -> 30
      10 -> 31
      11 -> 30
      12 -> 31
      _ -> error "invalid month"
    ```

  - 如果有多个匹配满足，那么只有第一个被返回。

- **守卫表达式（guarded expression）**

  - 守卫表达式是用 **|** 将函数的参数按特定的条件分开，**|** 像一个守卫一样，如果不能满足条件，它绝不会让不符合条件的表达式运算。不同条件的守卫表达式的 **|** 需要对齐。

  - ```
    abs' :: (Num a, Ord a) => a -> a
    abs' n | n > 0 = n
           | otherwise = -n
    ```

  - **otherwise** 是匹配时的默认定义。因为 | 后的一定是一个布尔类型，所以 **otherwise** 是布尔类型的值并且它的值很明显是True。在定义函数时可能有很多条件，但是如果有多个条件同时满足，Haskell只会匹配第一个。

- **模式匹配（pattern match）**

  - 模式匹配中的 pattern 理解为模式，它指的是一个类型的值或者定义成的形式。模式匹配的本质可以通过 `case .. of ..`表达式体现出来，即每个类型的数据（或着称为值）都可以看作是该类型的一个具体形式，我们仅仅是要把需要的情形依次写下，Haskell会从上到下的查询，直到找到第一个匹配，如果有多个符合的匹配，那么只有第一个匹配本执行。

  - ```
    month :: Int -> Int
    month 1 = 31
    month 2 = 28
    month 3 = 31
    month 4 = 30
    month 5 = 31
    month 6 = 30
    month 7 = 31
    -- month 2 = 40  -- 不会被匹配的定义
    month 8 = 31
    month 9 = 30
    -- month 5 = 20  -- 不会被匹配的定义
    month 10 = 31
    month 11 = 30
    month 12 = 31
    month _  = error “invalid month”

    > month 5
    31
    ```


- **运算符与函数**

  - 运算符，如加号，减号等，实质上是与函数式一样的。因为Haskell所有的运算符都是基于函数定义的。
  - 运算符不过是一些规定了可以放在参数中间或者末尾的函数，并且用了一些特殊的符号表示，将它们写在最前端实质是一样的。
  - 可以将一些二元函数用反单引号(\`)（位于数字1键左侧的键）来转换成位于参数中间的运算符。例如： 1 \`add\` 2 。

- **运算符与自定义运算符**

  - 运算符有 **3** 种属性。

    - 优先级（precedence）：运算符号有 0 ~ 9，共10个优先级。
    - 结合性（associativity）：左结合性、右结合性、无结合性。
    - 位置（fixity）：前缀、中缀、后缀。

  - 一般使用的函数常常可以理解为前缀运算符。

  - 定义的函数默认有着最高的优先级，比 9 还高，并且为左结合。例如， f g h i 意为 (((f g) h) i)。因此，在某些情况下，要对函数的参数加括号才能正确使用这些函数。

  - *下表展示了一些常用运算符的优先级和结合性，它们都是中缀运算符。*

    | --   | 左结合                   | 无结合                       | 右结合                 |
    | ---- | ------------------------ | ---------------------------- | ---------------------- |
    | 9    | `!!`                     |                              |                        |
    | 8    |                          |                              | ^,^^,**                |
    | 7    | `*`,`/`,``div``,``mod``, |                              |                        |
    |      | ``rem``,``quot``         |                              |                        |
    | 6    | `+`,`-`                  |                              |                        |
    | 5    |                          |                              | `:`, `++`              |
    | 4    |                          | `==`,`/=`,`<`,`<=`,`>`,`>=`, |                        |
    | 3    |                          |                              | `&&`                   |
    | 2    |                          |                              | `||`                   |
    | 1    | `>>`, `>>=`              |                              |                        |
    | 0    |                          |                              | `$`,`$!`,`$!!`,``seq`` |

  - **(!!)** 从一个列表中取出第 n 个元素（从 0 开始）。如果输入的数字大于等于列表的长度就会出现错误。例如，`[1,2,3,4,5]!!3` 结果为 4 。

  - **(.)**是复合函数的的运算符号。

  - **(^)**在Haskell里表示乘方。`(^)  :: (Num a, Integral b) => a -> b -> a`

  - **(^^)**也为乘方函数。          `(^^) :: (Integral b, Fractional a) => a -> b -> a`

  - **(\**)**也为乘方函数。          `(**) :: Floating a => a -> a -> a`

  - **mod、rem**为取余函数。两个函数载计算负数的时候，计算结果会有些不同。

  - **div、quot**为取商函数。两个函数载计算负数的时候，计算结果会有些不同。

  - **(:)**为元素列表连接运算符，用于将一个新的元素加入一个列表的第一个位置。

  - **(++)**为列表连接符，用于连接两个列表。

  - **($)**，当有多个函数应用时，Haskell默认计算为左结合，而这里因为`$`有着最低的优先级，并且是右结合的，那么使用`$`就可以避免过多的括号来定义函数。

    - 比如，当需要定义`f (g (h x))`时，可以写成`f $ g $ h x`。
    - 类型签名中的 `->` 为右结合，而函数的应用却是左结合的。即 `f g h` 意为 `(f g) h`，而 `a -> b -> c` 意为 `a -> (b -> c)`，这是因为类型签名中输入的类型在左，比如 `f :: a -> b -> c` 意为 f是输入一个 a 类型的值，返回一个有着 `b -> c`类型的函数。这样，输入参数的类型在左，可是应用函数到参数时对应的输入参数却写在函数名的右侧。即 `f x`，如此一来，函数应用的结合型与类型签名的结合型正好相反了。

  - **运算符只是定义了优先级的普通函数**。

  - 自定义运算符时，要声明它的结合型（infixl 为左结合，infixr为右结合，infix为无结合），优先级，最后给出运算符的符号。如果需要定义多个结合型与优先级相同的运算符，那么它们之间要用逗号分开：

  - ```haskell
    infixr 5 <->, <+>

    (<->), (<+>) :: Int -> Int -> Int
    (<->) x y = x – y

    (<+>) x y = x + y

    infixr 4 `foo` -- Haskell支持声明中缀函数的结合性与优先级

    foo a b = a + b
    ```

## 在GHCi中定义函数

在GHCi中定义函数时以let开头。（*现在可以不用let了???*）

`let f x y = 4 * x + y ^ 2`

模式匹配一定要写为多选的形式，此时在GHCi中还可以使用 :{开头，以:}结尾来定义多行参数。

```haskell
> :{
| let { foo :: Int -> Int
|     ; foo 1 = 2
|     ; foo 2 = 1
|     ; foo n = 0 }
| :}
```

## 总结

本章介绍了Haskell中