# é€’å½’å‡½æ•°

é€’å½’å‡½æ•°ï¼ˆrecursive functionï¼‰å°±æ˜¯ä¸€ä¸ªå‡½æ•°åœ¨è‡ªå·±è°ƒç”¨è‡ªå·±ï¼ŒçŸ¥é“ä¸€ç§ç‰¹æ®Šçš„æƒ…å†µä¸‹ï¼Œé€’å½’æ‰ä¼šåœæ­¢ã€‚



## é€’å½’å‡½æ•°çš„æ¦‚å¿µ

å¯¹äºä¸€åªä¸€èˆ¬çš„é€’å½’å‡½æ•°ï¼Œå‡½æ•°çš„å®šä¹‰å¯ä»¥åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼š

1. é€’å½’çš„åŸºæœ¬æ¡ä»¶ï¼ˆbase caseï¼‰
2. é€’å½’æ­¥éª¤ï¼ˆrecursive stepï¼‰

é€’å½’å‡½æ•°ä¼šä»ç»™å®šçš„å€¼ä¸€ç›´è°ƒç”¨å®ƒè‡ªå·±ã€‚åœ¨è°ƒç”¨çš„è¿‡ç¨‹ä¸­ï¼Œå‡½æ•°çš„å‚æ•°ä¸æ–­å‘ç”Ÿå˜åŒ–ï¼Œå‘åŸºæœ¬æ¡ä»¶é æ‹¢ï¼Œè°ƒç”¨ä¸€ç›´åˆ°æ»¡è¶³é€’å½’çš„åŸºæœ¬æ¡ä»¶æ‰åœæ­¢ã€‚

```haskell
{-
é˜¶ä¹˜å‡½æ•°
è¿™é‡Œçš„errorå‡½æ•°ç”¨æ¥è¿”å›å¼‚å¸¸ï¼Œç”±äºç»“æœå¯ä»¥å½“åšæ—¶å¤šæ€ç±»å‹ a ï¼Œå³ String -> aï¼Œè¿™æ ·å¯ä»¥è®©è¿”å›çš„ç»“æœå’Œå…¶å®ƒäººä¸€çš„ç±»å‹ç›¸åè°ƒã€‚
-} 
factorial n | n <  0 = error "n is less that 0"
            | n == 0 = 1
            | otherwise = n * factorial (n -1)
```

```haskell
-- æœ€å¤§å…¬çº¦å‡½æ•°
import Prelude hiding (gcd)
gcd :: Int -> Int -> Int
gcd x y = if y == 0 then x  else gcd y (mod x y)
```

å½“ç„¶ï¼Œä¸€ä¸ªé€’å½’å‡½æ•°çš„åŸºæœ¬æ¡ä»¶å¯èƒ½æœ‰å¤šä¸ªã€‚åŒæ ·ï¼Œé€’å½’æ­¥éª¤ä¹Ÿå¯èƒ½ä¸æ­¢ä¸€ä¸ªã€‚



## ç®€å•é€’å½’å‡½æ•°

å®šä¹‰æˆæ–¹å‡½æ•°powerï¼Œç”±äºxâ° = 1(x â‰ 0) å’Œ xâ¿ = x Ã— xâ¿â»Â¹(nâ©¾1,xâ‰ 0)ï¼ŒæŒ‡æ•°ä¸ºè‡ªç„¶æ•°çš„ä¹˜æ–¹å¯ä»¥å®šä¹‰ä¸º

```haskell
power, power' :: Int -> Int -> Int
power 0 0 = error "cannot calculate power 0 0 "
power _ 0 = 1
power x n = x * power x (n - 1)

{-
å½“æŒ‡æ•°ä¸ºå¶æ•°ï¼Œç”±äºxÂ²â¿ = xâ¿ Ã— xâ¿ï¼Œè¿™æ · xâ¿ å°±ä¸éœ€è¦è®¡ç®—ä¸¤æ¬¡ï¼Œè€Œ n ä¸ºå¥‡æ•°æ—¶ xÂ²â¿âºÂ¹ = xâ¿ Ã— xâ¿ Ã— x
ä¼˜åŒ–åçš„power
-}
power' 0 0 = error "cannot calculate power 0 0 "
power' _ 0 = 1
power' x n | odd n = let p = power' x ((n-1) `div` 2) in x * p * p
           | otherwise = let p = power' x (n `div` 2) in p * p
```



åœ¨å®šä¹‰åŸºäºåˆ—è¡¨çš„é€’å½’å‡½æ•°æ—¶éœ€è¦è€ƒè™‘ä¸¤ç§æƒ…å½¢

1.  åˆ—è¡¨é€’å½’çš„åŸºæœ¬å®šä¹‰ï¼Œå³ []

2.  åˆ—è¡¨è‡³å°‘æœ‰ä¸€ä¸ªå…ƒç´ çš„æƒ…å½¢ï¼Œå³ x : xs ä»£æŒ‡ä½™ä¸‹çš„åˆ—è¡¨ï¼Œå¹¶ä¸”ä½™ä¸‹çš„åˆ—è¡¨å¯èƒ½ä¸ºç©º

   ```haskell
   product' [] = 1   					--(1)
   product' (x:xs) = x * product' xs 	--(2)
   ```

   åœ¨ä½¿ç”¨åˆ—è¡¨æ—¶ï¼Œ(:)ä¸ºä¸€ä¸ªå‡½æ•°ã€‚å°†ä¸€ä¸ªå…ƒç´ æ”¾åœ¨ä¸€ä¸ªåˆ—è¡¨çš„ç¬¬ä¸€ä¸ªä½ç½®ï¼Œå®ƒå¸¸å¸¸è¢«ç§°ä¸ºåˆ—è¡¨çš„æ„é€ å‡½æ•°ï¼Œåœ¨æœ‰äº›ä¹¦ä¸­å¸¸å¸¸å†™ä½œconsã€‚

   ```haskell
   > let cons = (:)
   > cons 5 [1,2,3]
   [5,1,2,3]

   -- å‡½æ•°snocï¼Œå³ cons çš„ é€†å†™
   snoc :: a -> [a] -> [a]
   snoc x [] = [x]
   snoc e (x:xs) = x : snoc e xs
   > snoc 0 [1,2,3]
   [1,2,3,0]

   -- å®ç°reverseå‡½æ•°
   reverse' :: [a] -> [a]
   reverse' [] = []
   reverse' (x:[]) = [x]
   reverse' xs = (last xs) : (reverse' (init xs))
   > reverse' [1,2,3]
   [3,2,1]

   -- å®ç°lastå‡½æ•°
   last' :: [a] -> a
   last' [] = error "empty list"
   last' [x] = x
   last' (_:xs) = last' xs
   > last' [1,2,3]
   1

   --å®ç°takeå‡½æ•°
   take' :: Int -> [a] -> [a]
   take' n _ | n <= 0 = []
   take' _ [] = []
   take' n (x:xs) = x : take' (n-1) xs
   > take' 2 [1,2,3]
   [1,2]

   --å®ç°elemå‡½æ•°
   elem' :: Eq a => a -> [a] -> Bool
   elem' _ [] = False
   elem' e (x:xs) | e == x = True
                  | otherwise = elem' e xs
   > lem' 0 [1,2,3]
   False
   > elem' 1 [1,2,3]
   True

   --å®ç° Data.List ä¸­çš„ deleteå‡½æ•°
   delete' :: Eq a => a -> [a] -> [a]
   delete' _ [] = []
   delete' e (x:xs) = if e ==x then delete' e xs else x : delete' e xs
   > delete' 2 [4,2,4,6,2]
   [4,4,6]

   --å®ç°dropå‡½æ•°
   drop' :: Int -> [a] -> [a]
   drop' _ [] = []
   drop' n (x:xs) | n <= 0 = x:xs
                  | otherwise = drop' (n - 1) xs

   ```

   â€‹

## æ‰©å±•é€’å½’ä¸å°¾é€’å½’

```haskell
-- é˜¶ä¹˜å‡½æ•°
factorial :: Int -> Int
factorial n = if n == 0 then 1 else n * factorial (n - 1)

-- æœ€å¤§å…¬çº¦å‡½æ•°
mygcd :: Int -> Int -> Int
mygcd x y = if y == 0 then x else mygcd y (mod x y)
```

- é˜¶ä¹˜å‡½æ•°åœ¨æœªè¾¾åˆ°é€’å½’çš„åŸºæœ¬æ¡ä»¶å‰ä¸€ç›´åœ¨å±•å¼€ï¼Œå¹¶ä¸èƒ½è¿›è¡Œä»»ä½•è®¡ç®—ï¼Œæ‰€æœ‰çš„ä¸­é—´ç»“æœå°†ä¼šåœ¨æš‚æ—¶å­˜å‚¨çš„å†…å­˜çš„æ ˆä¸­ï¼Œè¶Šå è¶Šå¤šã€‚è¿™æ ·çš„é€’å½’ç§°ä¸º**æ‰©å±•é€’å½’ï¼ˆaugmenting recursionï¼‰**ï¼Œå³åœ¨é€’å½’æ­¥ä¸­é™¤è°ƒç”¨é€’å½’å‡½æ•°ä»¥å¤–è¿˜å‚ä¸äº†å…¶å®ƒçš„å‡½æ•°è®¡ç®—ã€‚

- æœ€å¤§å…¬çº¦æ•°è¿™æ ·çš„å‡½æ•°ï¼Œä¸å¿…å±•å¼€å°±å¯ä»¥è®¡ç®—ï¼Œå³é™¤é€’å½’åœ°è°ƒç”¨ä»¥å¤–æ²¡æœ‰ä»»ä½•å…¶ä»–çš„å‡½æ•°è®¡ç®—ï¼Œé€’å½’è°ƒç”¨çš„ç»“æœå³ä¸ºå‡½æ•°çš„è®°è¿‡ï¼Œå³ä¾¿é€’å½’å‡½æ•°çš„å‚æ•°è¿›è¡Œäº†å…¶å®ƒçš„è®¡ç®—ï¼Œåœ¨è®¡ç®—è¿‡ç¨‹ä¸­ä¹Ÿå¯ä»¥ä¸å¿…å±•å¼€ã€‚åƒè¿™æ ·çš„é€’å½’è¢«ç§°ä¸º**å°¾é€’å½’ï¼ˆtail recursionï¼‰**ï¼Œå³åœ¨é€’å½’çš„æ—¶å€™ä¸å¿…è¦å‘å†…å­˜ä¸­æš‚å­˜ä»»ä½•å€¼ã€‚å°¾é€’å½’æ˜¯ä¸€ç§ç‰¹æ®Šçš„æƒ…å†µã€‚

  ```haskell
  -- æ‰©å±•é€’å½’
  total :: Num t => [t] -> t
  total [] = 0
  total (x:xs) = x + total xs

  {- 
  	å°¾é€’å½’å®ç°
  	å¯ä»¥çœ‹åˆ°ï¼Œåˆ©ç”¨å°¾é€’å½’å¯ä»¥å°†ä»£ç ä¼˜åŒ–ï¼Œçœå»äº†åˆ†é…ä¸´æ—¶ç©ºé—´
  	å‡½æ•°total''ä¸­çš„å‚æ•°nç§°ä¸ºç´¯ç§¯å™¨ï¼ˆaccumulatorï¼‰ã€‚é€šå¸¸ï¼Œç±»æœºå™¨çš„ç±»å‹å’Œå‡½æ•°çš„ç»“æœç±»å‹ç›¸åŒã€‚ 
  -}
  total'' :: Num t => [t] -> t -> t
  total'' [] n = n
  total'' (x:xs) n = total'' xs (x + n)
  total' xs = total'' xs 0

  {-
  	æ‰©å±•é€’å½’å’Œå°¾é€’å½’çš„å…³ç³»
  	total xs + x = total' xs x
  	
  	1ï¼Œé€’å½’åŸºæœ¬æ¡ä»¶æƒ…å†µä¸‹ä¸¤è€…çš„å…³ç³»
  	total' [] n
  	= total [] + n        {total ä¸ total' çš„ç­‰ä»·å…³ç³»}
  	= 0 + n               {åº”ç”¨åŠ æ³•å‡½æ•°}
  	= n
  	2ï¼Œé€’å½’æ­¥éª¤æƒ…å†µä¸‹ä¸¤è€…çš„å…³ç³»
  	total' (x:xs) n
  	 = (total x + x) + n  {total ä¸ total' çš„ç­‰ä»·å…³ç³»}
  	 = total xs + (x + n) {åŠ æ³•ç»“åˆå¾‹}
  	 = total' xs (x + n) {é€†ç”¨ total ä¸ total' çš„ç­‰ä»·å…³ç³»}
  -}
  ```

- è¡¨é¢ä¸Šï¼Œè¿™æ ·çš„ä¼˜åŒ–æœ¬æ¥å¯ä»¥ä½¿Haskellä¸éœ€è¦æ›´å¤šçš„ç©ºé—´ã€‚å¯æ˜¯ï¼ŒHaskellæ˜¯ä¸€ä¸ªé»˜è®¤è®¾ç½®ä¸ºæƒ°æ€§æ±‚å€¼çš„è¯­è¨€ã€‚ 

- ç”±äºæƒ°æ€§æ±‚å€¼åœ¨ä½¿ç”¨å°¾é€’å½’æ—¶ä¹Ÿå¯èƒ½ä¼šäº§å“å’Œæ‰©å±•é€’å½’ä¸€æ ·çš„é—®é¢˜ï¼Œå› æ­¤ï¼Œåœ¨ total' å‡½æ•°è°ƒç”¨åˆ°é€’å½’åŸºæœ¬æ¡ä»¶å‰ï¼Œå‚æ•° n åªå‚ä¸å’Œ x çš„åŠ æ³•è¿è¡Œï¼ŒäºŒå¹¶ä¸ä½œä¸ºç»“æœä½¿ç”¨ï¼Œå³ n çš„å…·ä½“å€¼åœ¨é€’å½’åˆ°è¾¾åŸºæœ¬æ¡ä»¶å‰ä¸éœ€è¦è¢«è®¡ç®—ã€‚å› æ­¤ï¼ŒHaskellè¿˜æ˜¯ä¼šæŠŠè¿™äº›å€¼æš‚æ—¶å­˜äºå†…å­˜ä¸­ï¼Œç­‰åˆ°éœ€è¦çš„æ—¶å€™æ‰è®¡ç®—ã€‚

  ```haskell
  {-
  total'' [1, 2, 3] 0
  =total'' [2, 3] (1 +0)
  =total'' [3] (2 + (1 +0))
  =total'' [] (3+ (2 + (1 +0)))
  =(3+ (2 + (1 +0)))
  =(3+ (2 + 1))
  =(3+ 3)
  =6
  -}
  ```

- è¿™æ ·ï¼Œéœ€è¦ä½¿ç”¨ **å¹å·æ¨¡å¼ï¼ˆbang patternï¼‰åŒ¹é…**æˆ–è€…**($!)è¿ç®—ç¬¦**æ¥å¼ºåˆ¶Haskellå¯¹ total''çš„ç¬¬äºŒä¸ªå‚æ•°è¿›è¡Œæ±‚å€¼ã€‚

  ```haskell
  total'' [] n = n
  total'' (x:xs) n = total'' xs $! (x + n)
  -- total'' (x:xs) !n = total'' xs (x + n)
  ```


- **!æ¨¡å¼**æ˜¯å¼ºåˆ¶åœ¨å‚æ•°åŒ¹é…å‰æ¥è®¡ç®—å‚æ•°çš„å€¼ï¼Œ**!æ¨¡å¼**éœ€è¦åœ¨æ–‡ä»¶é¦–æ¬¡å£°æ˜ **{-# LANGUAGE BangPatterns #-}** è¯­è¨€æ‰©å±•ã€‚è€Œ**($!)**åˆ™ä¸ºç¾è°ƒç”¨å‡½æ•°æ—¶è®¡ç®—å‚æ•°çš„å€¼ã€‚

  ```haskell
  {-
  total'' [1, 2, 3] 0
  =total'' [2, 3] (1 +0)
  =total'' [2, 3] 1
  =total'' [3] (2 + 1)
  =total'' [3] 3
  =total'' [] (3+ 3)
  =total'' [] 6
  =6
  -}
  ```

  â€‹

## äº’è°ƒé€’å½’

**äº’è°ƒé€’å½’ï¼ˆmutual recursionï¼‰**æ˜¯ä¸€ç§ç‰¹æ®Šçš„æƒ…å½¢ï¼Œå³ä¸¤ä¸ªå‡½æ•°çš„å®šä¹‰åˆ†åˆ«éƒ½ç”¨åˆ°äº†å¯¹æ–¹ã€‚

```haskell
even' 0 = True
even' n = odd' (n -1)

odd' 0 = False
odd' n = even' (n - 1)
```

è¿™ç§äº’è°ƒé€’å½’æ˜¯é—´æ¥é€’å½’çš„ä¸€ç§ç‰¹ä¾‹ã€‚

## éº¦å¡é”¡çš„91å‡½æ•°

```haskell
mc n | n > 100 = n - 10
     | otherwise = mc (mc (n + 11))
```



## æ–æ³¢é‚£å¥‘æ•°åˆ—

```haskell
-- æ€§èƒ½å·®çš„ç‰ˆæœ¬
fibonacci :: (Num a, Eq a) => a -> a -- æ•°å­—ç±»å‹çš„æ¨¡å¼åŒ¹é…éœ€è¦Eqç±»å‹ç±»
fibonacci 0 = 1
fibonacci 1 = 1
{-
è¿™ç§é€’å½’å‡½æ•°ç§°ä¸ºå¤šé‡é€’å½’ï¼ˆmultiple recursionï¼‰æˆ–è€…å¤šåˆ†æ”¯é€’å½’ã€‚
å®ƒæ˜¯ä¸€ç§ç‰¹æ®Šçš„é€’å½’ï¼Œå³ä¸€ä¸ªå‡½æ•°ä¸­é€’å½’è°ƒç”¨å¤šæ¬¡ã€‚
-}
fibonacci n = fibonacci (n - 1) + fibonacci (n - 2)

fibs n = map fibonacci [0..n-1]

-- ä¼˜åŒ–æ€§èƒ½åçš„ç‰ˆæœ¬
fibStep :: Num a => (a, a) -> (a, a)
fibStep (u, v) = (v, u + v)

fibPair :: (Num a, Eq a) => a -> (a, a)
fibPair 0 = (0, 1)
fibPair n = fibStep (fibPair (n - 1))

fastFib :: (Num a, Eq a) => a -> a
fastFib n =snd (fibPair n)

fastFibs n = map fastFib [0..n-1]

-- è¿­ä»£ç‰ˆæœ¬
fibs' n = take n (map snd (iterate fibStep (0, 1)))

-- å°¾é€’å½’ç‰ˆæœ¬
fib 0 f1 f2 = f2
fib n f1 f2 = fib (n - 1) f2 (f1 + f2)
fibonacci' n = fib n 0 1
fibs'' n = map fibonacci' [0..n-1]
```

- æ–æ³¢é‚£å¥‘æ•°åˆ—ç‰¹æ€§ï¼Œå‰ä¸€ä¸ªæ•°ä¸åä¸€ä¸ªæ•°çš„æ¯”å€¼é€¼è¿‘é»„é‡‘åˆ†å‰²å€¼ã€‚

  ```haskell
  golden :: Fractional a => Int -> [a]
  golden n = take n (map (\(x,y) -> x/y) (iterate fibStep (0, 1)))

  > golden 30
  [0.0,1.0,0.5,0.6666666666666666,0.6,0.625,0.6153846153846154,0.6190476190476191,0.6176470588235294,0.6181818181818182,0.6179775280898876,0.6180555555555556,0.6180257510729614,0.6180371352785146,0.6180327868852459,0.6180344478216818,0.6180338134001252,0.6180340557275542,0.6180339631667066,0.6180339985218034,0.618033985017358,0.6180339901755971,0.6180339882053251,0.618033988957902,0.6180339886704432,0.6180339887802427,0.618033988738303,0.6180339887543226,0.6180339887482036,0.6180339887505408]

  -- ç”¨Haskellæ¥ç²—ç•¥è®¡ç®—ä¸€ä¸‹é»„é‡‘åˆ†å‰²çš„å€¼
  > (sqrt 5 - 1) /2
  0.6180339887498949
  ```

  â€‹

- æ–æ³¢é‚£å¥‘æ•°åˆ—ç‰¹æ€§ï¼Œ4ä¸ªç›¸è¿çš„æ•´æ•°çš„å†…ç§¯å’Œå¤–ç§¯ç›¸å·®1ã€‚Fğ—‡-â‚Fğ—‡â‚Šâ‚ - (Fğ—‡)Â² = (-1)â¿

  ```haskell
  combine :: [(a,a)] ->[(a,a,a)]
  combine ((f1,f2):(f3,f4):fs) = (f1,f2,f4):combine ((f3,f4):fs)
  combine _ = []

  fibPairs :: Int -> [(Int, Int)]
  fibPairs n = map fibPair [1..n]
  > combine $ fibPairs 7
  [(1,1,2),(1,2,3),(2,3,5),(3,5,8),(5,8,13),(8,13,21)]

  difference :: Int -> [Int]
  difference n = map (\(f1,f2,f3)->f1*f3-f2*f2) (combine $ fibPairs n)
  >diffence 10
  [1,-1,1,-1,1,-1,1,-1,1]
  ```

## åè¿›åˆ¶æ•°å­—è½¬æ¢æˆç½—é©¬æ•°å­—

```haskell
romeNotation :: [String]
romeNotation = ["M","CM","D","CN","C","XC","L","XL","X","IX","V","IV","I"]

romeAmount :: [Int]
romeAmount = [1000,900,500,400,100,90,50,40,10,9,5,4,1]

pair :: [(Int, String)]
pair = zip romeAmount romeNotation

subtrahend :: Int -> (Int, String)
subtrahend n = head (dropWhile (\(a,_) -> a > n) pair)

convert :: Int -> String
convert 0 = ""
convert n = let (rome, m) = subtrahend n
                 in m ++ convert (n-rome)               
> convert 12
"XII"
> convert 109
"CIX"
> convert 4567
"MMMMDLXVII"   

{-
convert 17
= "X"   + convert(17-10)
= "XV"  + convert(7-5)
= "XV"  + convert(2)
= "XVI" + convert(2-1)
= "XVI" + convert(1)
= "XVII
-}

-- åè¿›åˆ¶è½¬äºŒè¿›åˆ¶
decimalToBinary :: Integral a => a -> String
decimalToBinary n | n < 0  = error "unsupported number"
                  | n == 0 = ""
                  | otherwise = let bit= if odd n then "1" else "0" in (decimalToBinary (n `div` 2)) ++ bit
```

##äºŒåˆ†æ³•æŸ¥æ‰¾

```haskell
-- éœ€è¦æœ‰åºçš„åˆ—è¡¨
binarySearch :: (Ord a) => a -> [a] -> Bool
binarySearch _ [] = False
binarySearch a (x:[]) = a == x
binarySearch a xs | m < a = binarySearch a behind
                  | m > a = binarySearch a front
	              | otherwise = True
	              where (front, m:behind) = splitAt (length xs `div` 2) xs

-- æŸ¥æ‰¾å¹¶è¿”å›å…ƒç´ 	        
search :: (Ord a) => a -> [a] -> [a]
search _ [] = []
search a (x:xs) | a == x  = a : search a xs
                | otherwise = search a xs
```

## æ±‰è¯ºå¡”

```haskell
{-
å‡è®¾æœ‰nä¸ªé‡‘ç‰‡çš„æ—¶å€™è¦ç§»åŠ¨ h(n) æ¬¡ã€‚

å½“æœ‰ä¸€ä¸ªé‡‘ç‰‡çš„æ—¶å€™ï¼Œç›´æ¥ç§»åŠ¨å°±å¥½äº†ï¼Œéœ€è¦ h(1) = 1 æ¬¡ã€‚

å½“æœ‰ n ä¸ªé‡‘ç‰‡çš„æ—¶å€™ï¼Œéœ€è¦å°†n - 1 ä¸ªé‡‘ç‰‡ç§»åŠ¨åˆ°éç›®æ ‡é’ˆä¸Šï¼Œéœ€è¦h(n-1)æ¬¡ã€‚è‡³äºæ€ä¹ˆç§»åŠ¨çš„ä¸éœ€è¦çŸ¥é“ï¼Œç„¶åå°†æœ€åº•ä¸‹çš„é‡‘ç‰‡ç§»åŠ¨åˆ°ç›®æ ‡é’ˆã€‚æœ€åï¼Œå†å°†éç›®æ ‡é’ˆä¸Šçš„ n-1 ä¸ªé‡‘ç‰‡åŒæ ·ç”¨å“ªä¸ªä¸éœ€è¦çŸ¥é“çš„æ–¹æ³•ç§»åŠ¨åˆ°ç›®æ ‡é’ˆä¸Šå³å¯ã€‚æ­¤æ—¶ä¹Ÿéœ€è¦ h(n-1)æ¬¡ã€‚

è¿™æ ·ï¼Œæ‰€éœ€è¦ç§»åŠ¨çš„æ€»æ¬¡æ•°ä¸º h(n) = h(n-1) + 1 + h(n-1) = 2h(n-1) + 1
-}
{-
 å‚æ•°è¯´æ˜
 é‡‘ç‰‡æ•°ï¼›ä»å“ªé‡Œç§»åŠ¨ï¼›ç§»åŠ¨åˆ°å“ªé‡Œï¼›ç§»åŠ¨è¿‡ç¨‹ä¸­å¯ä»¥å€ŸåŠ©å“ªæ ¹é’ˆ
-} 
move (1, from, to, via) = [(from, to)]
move (n, from, to, via) = move (n-1, from, via, to) ++
                         [(from, to)] ++
			 move (n-1, via, to, from)
hanoi n = move (n, 1, 2, 3)
hanoiCnt n = length $ hanoi n

hanoiCnt' 1 = 1
hanoiCnt' n = 2 * hanoiCnt'(n-1) + 1
```

## æ’åºç®—æ³•

### æ’å…¥æ’åºï¼ˆinsertion sortï¼‰

å½“åˆ—è¡¨ä¸ºç©ºçš„æ—¶å€™ï¼Œç›¸å½“äºæ‰‹é‡Œæ²¡ç‰Œï¼Œç›´æ¥æ‹¿å°±å¯ä»¥äº†ã€‚å½“æ‰‹ä¸­æœ‰äº†ä¸€äº›æœ‰åºçš„ç‰Œåï¼Œåœ¨æ’å…¥æ–°ç‰Œçš„æ—¶ï¼Œè‹¥å®ƒæ¯”å½“å‰æ¯”è¾ƒçš„ç‰Œå°ï¼Œæˆ¿å­å•Šå‰è¾¹å°±å¥½ï¼Œè‹¥æ¯”å½“å‰æ¯”è¾ƒçš„ç‰Œå¤§ï¼Œåªéœ€è¦é€’å½’åœ°å°†æ–°ç‰Œæ’å…¥åˆ°åè¾¹çš„ç‰Œé‡Œã€‚

```haskell
insert, insert' :: Ord t => t -> [t] -> [t]
insert n [] = [n]
insert n a | n <= h = n : a
           | otherwise = h : (insert n t) 
	   where
	     h = head a; t = tail a
> insert 7 [5,12,10]
[5,7,10,12]

-- å°¾é€’å½’å®ç°
insert' n [] = [n]
insert' n (x:xs) | n <= x = n : x : xs
                 | otherwise = x : (insert' n xs)  
> insertionSort [] [7,5,12,10]
[5,7,10,12]

-- æ‰©å±•é€’å½’å®ç°
insertionSort' :: Ord t => [t] -> [t]
insertionSort' [] = []
insertionSort' (x:xs) = insert x (insertionSort' xs)
> insertionSort' [7,5,12,10]
[5,7,10,12]
```

### å†’æ³¡æ’åºï¼ˆbubble sortï¼‰

é€šè¿‡ä¸æ–­åœ°å°†è¾ƒå¤§çš„ç‰Œå‘å³äº¤æ¢ï¼Œé‡å¤å¤šæ¬¡å°±å¯ä»¥å¾—åˆ°ä¸€æ²“æœ‰åºçš„ç‰Œï¼Œæ¯è¿è¡Œåˆ°ç»“å°¾ï¼Œæœ€åä¸€å¼ ç‰Œæ€»æ˜¯æœ€å¤§çš„ï¼Œè¿™ä¸ªæœ€å¤§çš„è¢«ç§°ä¸ºâ€œæ³¡â€ã€‚

```haskell
-- äº¤æ¢ä¸€ä¸ªå…ƒç´ 
swaps :: Ord t => [t] -> [t]
swaps [] = []
swaps[x] = [x]
swaps (x1:x2:xs) | x1 <= x2 = x1 : swaps (x2:xs)
                 | otherwise = x2 : swaps (x1:xs)

-- å®šä¹‰ä¸€ä¸ªä¸åŠ¨ç‚¹å‡½æ•°ã€‚è¿™ä¸ªå‡½æ•°å¯ä»¥ä¸€ç›´è°ƒç”¨ swapsï¼Œä¸€åªåˆ°åˆ—è¡¨ä¸å†å‘ç”Ÿå˜åŒ–ä¸ºæ­¢
fix :: Eq a => (a -> a) -> a -> a
fix f x = if x == x' then x else fix f x'
                            where x' = f x

-- å†’æ³¡æ’åºä¸è¿‡æ˜¯ä¸€ä¸ªåå¤è°ƒç”¨ swaps çš„å‡½æ•°
bubbleSort :: Ord a => [a] -> [a]
bubbleSort xs = fix swaps xs

> bubbleSort [7,12,3,5,10]
[3,5,7,10,12]

{-
è¦é‡å¤åŒ–ç®€ä¸€ç»„æ•°æ®ï¼Œä½†æ˜¯åŒ–ç®€åçš„æ•°æ®è¿˜å¯ä»¥è¢«ç»§ç»­åŒ–ç®€ï¼Œè€…ä¸€ç±»çš„é—®é¢˜å°±å¯ä»¥äº¤ç»™ fix å‡½æ•°æ¥å¤„ç†,
å®è´¨ä¸Šä¸åŠ¨ç‚¹å‡½æ•°å¼å¯ä»¥ä»£æ›¿é¡ºåºå¼ç¼–ç¨‹è¯­è¨€ä¸­çš„å¾ªç¯çš„ã€‚
-}
-- ç›¸å½“äºæŠŠ fix éšè—åœ¨ bubbleSort' ä¸­
bubbleSort' :: Ord a => [a] -> [a]
bubbleSort' xs | swaps xs == xs = xs
               | otherwise bubbleSort' $ swaps xs
--ä¼˜åŒ–ç‰ˆæœ¬çš„å†’æ³¡æ’åº
{-
æ—¢ç„¶æœ€å¤§çš„å·²ç»è¢«äº¤æ¢åˆ°äº†æœ€å³è¾¹äº†ï¼Œå°±æ²¡æœ‰å¿…è¦å†ä½¿ç”¨äº¤æ¢å‡½æ•°äº†ã€‚å› æ­¤ï¼Œå¯ä»¥å°†äº¤æ¢å®Œæ¯•çš„åˆ—è¡¨åˆ†æˆå‰ n-1 é¡¹ä¸æœ€åä¸€é¡¹ï¼Œæœ€åä¸€é¡¹å¯ä»¥ä¸ç”¨åŠ¨äº†ï¼Œå†é€’å½’è°ƒç”¨bubbleSort''ï¼Œæ¥å¯¹å‰ n-1 é¡¹ æ’åº
-}
bubbleSort'' :: Ord a => [a] -> [a]
bubbleSort'' [] = []
bubbleSort'' xs = bubbleSort'' initialElements ++ [lastElement]
                  where swappedxs = swaps xs
		                initialElements = init swappedxs
		                lastElement = last swappedxs
```

### é€‰æ‹©æ’åºï¼ˆselection sortï¼‰

é¦–å…ˆæ‰¾åˆ°æœ€å°çš„å…ƒç´ ï¼Œå°†å…¶ä»åˆ—è¡¨ä¸­å–å‡ºï¼Œæ”¾äºå¦ä¸€ä¸ªåˆ—è¡¨çš„åœ°ä¸€ä¸ªä½ç½®ï¼ŒçŸ¥é“æ‰€æœ‰çš„å…ƒç´ å…¨éƒ¨è¢«å–å…‰ã€‚

```haskell
delete :: Eq t => t -> [t] -> [t]
delete _ [] = []
delete e (x:xs) | e == x = xs
                | otherwise = x : delete e xs
                
selectionSort :: Ord t => [t] -> [t]
selectionSort [] = []
selectionSort xs = mini : selectionSort xs'
                   where mini = minimum xs
		         xs' = delete mini xs
> selectionSort [9,8..1]		         
[1,2,3,4,5,6,7,8,9]
```

### å¿«é€Ÿæ’åºï¼ˆquick sortï¼‰

å¿«é€Ÿæ’åºçš„åŸºæœ¬æ€è·¯æ˜¯ï¼šå–å‡ºä¸€å¼ ç‰Œï¼Œä½œä¸ºä¸€ä¸ªåˆ†ç•Œç‚¹ï¼Œç„¶åç­›é€‰å‡ºæ¯”å…¶å°çš„ä½œä¸ºä¸€ç»„ã€‚æ¯”å…¶å¤§çš„ä½œä¸ºä¸€ç»„ï¼Œåˆ†åˆ«å†ç”¨å¿«é€Ÿæ’åºç®—æ³•é€’å½’åœ°å¯¹è¿™ä¸¤ç»„è¿›è¡Œæ’åºåï¼ŒæŠŠåˆ†ç•Œç‚¹ä¸æ’åºå¥½çš„ä¸¤ç»„ç‰Œè¿›è¡Œç»„åˆå³å¯ã€‚

```haskell
quickSort :: Ord t => [t] -> [t]
quickSort [] = []
quickSort (x:xs) = quickSort mini ++ [x] ++ quickSort maxi
      where mini = filter (<x) xs
            maxi = filter (>=x) xs

> quickSort [4,5,7,2,3,4,6,0,9,8,5,3,1]
[0,1,2,3,3,4,4,5,5,6,7,8,9]

{-
è™½ç„¶ä¸Šé¢çš„å‡½æ•°å¾ˆç®€å•ï¼Œä½†ç”±ä¸¤ä¸ªé—®é¢˜ï¼Œå…¶ä¸€ï¼Œäº§ç”Ÿäº†å¾ˆå¤šçš„[]ï¼Œè¿™ä¸ªéå¸¸å¥½è§£å†³ï¼Œåªè¦åŠ ä¸€æ¡ quickSort [x] = [x]å³å¯ã€‚å…¶äºŒï¼Œå½“ç­›é€‰å‡ºæ¯” x å°çš„å…ƒç´ æ—¶ï¼Œè¦å°†åˆ—è¡¨éå†ä¸€æ¬¡ï¼Œç­›é€‰å‡ºå¤§äºç­‰äº x çš„åŸå§‹æ—¶ï¼Œåˆè¦éå†ä¸€æ¬¡ã€‚å› æ­¤ï¼Œå¯ä»¥å®šä¹‰ä¸€ä¸ªå‡½æ•°ï¼Œå½“éå†åˆ—è¡¨æ—¶ï¼Œä¸€æ¬¡æ€§åœ°å°†å…¶åˆ†å¥½ç»„ï¼Œç„¶åè¢« quickSort å‡½æ•°æ‰€ç”¨ã€‚è¿™ä¸ªå‡½æ•°éœ€è¦ä¸€ä¸ªæ¡ä»¶å‡½æ•°æ¥çš„å€¼å¦‚ä½•ç­›é€‰ï¼Œç„¶åéœ€è¦ä¸€ä¸ªåˆ—è¡¨è¿›è¡Œç­›é€‰ï¼ŒæŠŠç»“æœçš„ä¸¤éƒ¨åˆ†å½“æˆä¸€ä¸ªå…ƒç»„è¿”å›ã€‚
-}

-- ä¼˜åŒ–åçš„å¿«é€Ÿæ’åº
filterSplit :: (a->Bool) -> [a] -> ([a], [a])
filterSplit _ [] = ([], [])
filterSplit f (x:xs) | f x = ((x:l), r)
                     | otherwise = (l, (x:r))
              where (l, r) = filterSplit f xs

quickSort' :: Ord t => [t] -> [t]
quickSort' [] = []
quickSort' [x] = [x]
quickSort' (x:xs) = quickSort' l ++ [x] ++ quickSort' r
      where (l, r) = filterSplit (<x) xs
```

### å½’å¹¶æ’åºï¼ˆmerge sortï¼‰

é‡‡ç”¨åˆ†æ²»æ³•ï¼ˆdivide and conquerï¼‰çš„æ€æƒ³ã€‚ç®—æ³•çš„è¿‡ç¨‹å¤§çº¦æ˜¯ï¼šå…ˆå°†ç‰Œå‡åŒ€åœ°åˆ†æˆä¸¤éƒ¨åˆ†ï¼Œå°†è€…ä¸¤éƒ¨åˆ†åˆ†åˆ«ç”¨å½’å¹¶æ’åºç®—æ³•ï¼Œç„¶åç”¨ä¸€ä¸ªå‡½æ•°å°†è€…ä¸¤æ²“æœ‰åºçš„ç‰Œåˆå¹¶ä¸ºä¸€æ²“æœ‰åºçš„ç‰Œã€‚é‚£ä¹ˆï¼Œå½“ç”¨å½’å¹¶æ’åºé‚£ä¸¤éƒ¨åˆ†çš„æ—¶å€™ï¼Œå®é™…ä¸Šæ˜¯åˆå°†è€…ä¸¤éƒ¨åˆ†ç‰Œç»§ç»­å‡åˆ†ï¼Œç„¶åé€’å½’åœ°ä½¿ç”¨è¿™ä¸ªæ’åºæ–¹æ³•ï¼Œé€’å½’çš„åŸºæœ¬æ¡ä»¶æ˜¯ä¸€å¼ ç‰Œè‡ªå·±æ˜¯æœ‰åºçš„ã€‚

```haskell
merge :: Ord a => [a] -> [a] -> [a]
merge xs [] = xs
merge [] xs = xs
merge (x:xs) (y:yx) | x > y = y:merge (x:xs) yx
                    | otherwise = x:merge xs (y:yx)
                    
msort :: Ord a => [a] -> [a]
msort [x] = [x]
msort xs = merge (msort x1) (msort x2)
  where
    (x1, x2) = halve xs
    halve xs = (take l xs, drop l xs)
    l        = (length xs) `div` 2
```

### å°ç»“

æœ¬ç« æ‰€è®¨è®ºçš„å¾ˆå¤šé—®é¢˜ï¼Œå¦‚æ–æ³¢é‚£å¥‘æ•°åˆ—ã€æ±‰è¯ºå¡”ã€å¿«é€Ÿæ’åºä¸å½’å¹¶æ’åºï¼Œéƒ½æœ‰ä¸€ä¸ªå…±åŒç‚¹ï¼Œé‚£å°±æ˜¯åœ¨ç”¨å®šä¹‰æ—¶æœ‰å¾ˆå¤šé€’å½’è°ƒç”¨çš„åˆ†æ”¯ï¼Œæ¯”å¦‚ï¼š

- æ–æ³¢é‚£å¥‘æ•°åˆ—ä¸­çš„ fibonacci n = fibonacci (n - 1) + fibonacci (n - 2) ï¼›
- æ±‰è¯ºå¡”ä¸­çš„  move (...) = move(â€¦) ++ [(from, to)] ++ move (â€¦)ï¼›
- å¿«é€Ÿæ’åºä¸­çš„ quickSort' (x:xs) = quickSort' l ++ [x] + quickSort' rï¼›
- å½’å¹¶æ’åºä¸­çš„ msort xs = merge (msort x1) (msort x2)

â€‹    è¿™æ ·çš„ä¾‹å­è¿˜æœ‰å¾ˆå¤šã€‚è¿™æ ·çš„é€’å½’ç§°ä¸ºå¤šåˆ†æé€’å½’ï¼ˆmulti-branched recursionï¼‰ã€‚åœ¨è§£å†³é—®é¢˜æ—¶ï¼Œåƒè¿™æ ·ä¸æ–­åœ°å°†é—®é¢˜é€’å½’åœ°è½¬æ¢æˆå¤šä¸ªå°é—®é¢˜çš„æ–¹æ³•ç§°ä¸ºåˆ†æ²»ç®—æ³•ï¼ˆdivide and conquer algorithmï¼‰ã€‚

å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€æ˜¯ä¸€ç±»éå¸¸é«˜çº§çš„è¯­è¨€ï¼Œå› ä¸ºåˆ†é…ä¸å›æ”¶å†…å­˜ã€ç§»åŠ¨æŒ‡é’ˆã€å£°æ˜å˜é‡ç­‰åœ¨è¿™é‡Œå‡ ä¹å¯ä»¥å…¨éƒ¨å¿½ç•¥ï¼Œå¹¶ä¸”åŸºäºåˆ—è¡¨è¿™ç§é€’å½’ç»“æ„çš„å®¹å™¨æ¥ç¼–ç¨‹çš„è‡ªç”±åº¦ä¹Ÿå¾ˆå¤§ã€‚

### é€’å½’åŸºæœ¬æ¡ä»¶ä¸ç¨‹åºç»ˆæ­¢

æœ‰è¿™æ ·ä¸€ç±»é€’å½’å‡½æ•°ï¼Œæ— æ³•ç¡®å®šé€’å½’åŸºæœ¬æ¡ä»¶ä¸€å®šå¯ä»¥åˆ°è¾¾ã€‚

```haskell
--å¯¹äºè¿™ä¸ªç¨‹åºï¼Œäººä»¬è¿˜æ— æ³•è¯æ˜å®ƒæ˜¯å¦ä¸€å®šå¯ä»¥åˆ°è¾¾é€’å½’çš„åŸºæœ¬æ¡ä»¶
halt :: Integral a => a ->[a]
halt 1 = [1]
halt n | even n = let n' = div n 2 in n':halt n'
       | otherwise = let n' = 3*n+1 in n':halt n'
```

è¿™ä¸€ç±»é€’å½’å‡½æ•°ç•¥åˆäº›ä¸åŒã€‚è™½ç„¶ä¸èƒ½å¾ˆå®¹æ˜“åœ°ç›´æ¥çœ‹å‡ºæˆ–è€…è¯æ˜å®ƒä¼šåœä¸‹æ¥ï¼Œä½†æ˜¯ä»–ä»¬æ€»è¢«ä»»åŠ¡æ˜¯ä¼šåœä¸‹æ¥çš„ï¼Œå¯æƒœå¾ˆéš¾ç»™å‡ºè¯æ˜ï¼Œè¿™å°±æ˜¯è‘—åçš„è€ƒæ‹‰å…¹çŒœæƒ³ï¼ˆCollatz conjecture ï¼Œä¹Ÿæœ‰è¯‘ä½œå¥‡å¶å½’ä¸€çŒœæƒ³ï¼‰ï¼Œç”Ÿæˆçš„è¿™ä¸ªåºåˆ—ç§°ä¸ºè€ƒæ‹‰å…¹åºåˆ—ï¼ˆCollatz sequenceï¼‰ã€‚

ç°åœ¨ï¼Œè¯»è€…å¯ä»¥çŸ¥é“ï¼Œé€’å½’æ˜¯å¦ä¼šåˆ°è¾¾åŸºæœ¬æ¡ä»¶ç„¶ååœæ­¢ï¼Œå¯¹äºç¨‹åºæ¥è¯´è‡³å…³é‡è¦ã€‚

### é€’å½’ä¸ä¸åŠ¨ç‚¹

fixå‡½æ•°ï¼Œä»–å°±æ˜¯ä¸åŠ¨ç‚¹å‡½æ•°ï¼ˆfixed point functionï¼‰ã€‚å‡½æ•°çš„ä¸åŠ¨ç‚¹æ„ä¸ºå½“å‚æ•°åº”ç”¨åˆ°è¿™ä¸ªå‡½æ•°æ—¶ï¼Œç»“æœæ˜¯è¿™ä¸ªå‚æ•°æœ¬èº«ã€‚

### æ— åŸºæœ¬æ¡ä»¶é€’å½’å’Œæƒ°æ€§æ±‚å€¼

åœ¨Haskellä¸­æœ‰ç€è¿™æ ·ä¸€ç±»çš„é€’å½’ï¼šå®ƒä»¬å¹¶æ²¡æœ‰é€’å½’çš„åŸºæœ¬æ¡ä»¶ï¼Œè€Œä»…ä»…æœ‰ä¸€ä¸ªé€’å½’æ­¥ï¼Œæ¯”å¦‚ä¸ŠèŠ‚ä¸­çš„ä¸åŠ¨ç‚¹å‡½æ•°ã€‚è¿™äº›å‡½æ•°è½½ä¸æ–­çš„è°ƒç”¨è‡ªèº«ï¼Œä½†å´æ²¡æœ‰åœæ­¢æ¡ä»¶ã€‚

```haskell
-- [1..]
ones = 1:ones

ones
= 1:ones
= 1:(1:ones)
= 1:(1:(1:ones))
....
> take 10 ones
[1,1,1,1,1,1,1,1,1,1]

nature = 0 : map(+1) nature
> take 10 nature
[0,1,2,3,4,5,6,7,8,9]

fibs = (0:1:zipWith (+) fibs (tail fibs))
> take 100 fibs
[0,1,1,2,3,5,8,13,21,34]
```

è™½ç„¶åˆ—è¡¨æ˜¯æ— ç©·çš„ã€‚ä½†æ˜¯é€šè¿‡æƒ°æ€§æ±‚å€¼ï¼Œç”¨`take`ä¼šä½¿å–å‰è¿¹è±¡çš„è®¡ç®—è¿‡ç¨‹åœæ­¢ã€‚

è¿™ä¹Ÿå°±è¯´æ˜äº†Haskellåœ¨è®¡ç®—æ—¶å¹¶æ²¡æœ‰å®Œå…¨è®¡ç®—æ•´ä¸ªåˆ—è¡¨è€Œæ˜¯ä»…ä»…è®¡ç®—å®ƒæ‰€éœ€è¦çš„éƒ¨åˆ†ã€‚

#### å˜å¾—æ‡’æƒ°

```haskell
{-
 è¯¥å‡½æ•°å­˜åœ¨çš„é—®é¢˜
 é—®é¢˜ä¸€ï¼šå¦‚æœä¸€ä¸ªåˆ—è¡¨çš„é•¿åº¦æ˜¯æœ‰é™çš„ï¼Œå¦å¤–ä¸€ä¸ªæ˜¯æ— é™çš„ï¼Œé‚£ä¹ˆè¿™ä¸ªå‡½æ•°åˆ™ä¸ä¼šåœæ­¢ã€‚
 é—®é¢˜äºŒï¼šå› ä¸º length :: [a] -> Intï¼ŒInt æ˜¯æœ‰èŒƒå›´çš„ã€‚æ‰€ä»¥ï¼Œå¦‚æœåˆ—è¡¨çš„é•¿åº¦å¤§äºIntçš„å€¼ï¼Œè¿™æ ·å°±å¯èƒ½ä¼šå¾—åˆ°è´Ÿå€¼è€Œå¯¼è‡´é”™è¯¯çš„æ¯”è¾ƒç»“æœã€‚æ‰€ä»¥ï¼Œå¦‚æœå¤„ç†çš„åˆ—è¡¨é•¿åº¦å¯èƒ½è¶…è¿‡ Int çš„èŒƒå›´ï¼Œå°±éœ€è¦ä½¿ç”¨ Data.List ä¸­çš„ genericLength å‡½æ•°ã€‚
-}
shorter :: [a] -> [a] -> [a]
shorter xs ys | x < y = xs
              | otherwise = ys
              where
                  x = length xs
                  y = length ys
                  
--ä¿®æ”¹åçš„å‡½æ•°
-- é€šè¿‡æƒ°æ€§æ±‚å€¼çš„ç‰¹æ€§ï¼Œåªè¦æœ‰ä¸€ä¸ªåˆ—è¡¨ä¸ºç©ºæ—¶ï¼Œå°±ç›´æ¥è¿”å›ç»“æœï¼Œè€Œä¸å†å»è®¡ç®—å¦ä¸€ä¸ªåˆ—è¡¨äº†ã€‚è¿™æ ·ï¼Œå³ä¾¿å¦å¤–ä¸€ä¸ªåˆ—è¡¨æ˜¯æ— é™çš„ï¼Œä¹Ÿä¸ä¼šä½¿è¿™ä¸ªè®¡ç®—å¡ä½ã€‚
lazyShorter :: [a] -> [a] -> [a]
lazyShorter xs ys = if short xs ys then xs else ys
              where short [] ys = True
                    short xs [] = False
                    short (x:xs) (y:ys) = short xs ys
```

