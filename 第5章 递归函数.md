# é€’å½’å‡½æ•°

é€’å½’å‡½æ•°ï¼ˆrecursive functionï¼‰å°±æ˜¯ä¸€ä¸ªå‡½æ•°åœ¨è‡ªå·±è°ƒç”¨è‡ªå·±ï¼ŒçŸ¥é“ä¸€ç§ç‰¹æ®Šçš„æƒ…å†µä¸‹ï¼Œé€’å½’æ‰ä¼šåœæ­¢ã€‚



## é€’å½’å‡½æ•°çš„æ¦‚å¿µ

å¯¹äºä¸€åªä¸€èˆ¬çš„é€’å½’å‡½æ•°ï¼Œå‡½æ•°çš„å®šä¹‰å¯ä»¥åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼š

1. é€’å½’çš„åŸºæœ¬æ¡ä»¶ï¼ˆbase caseï¼‰
2. é€’å½’æ­¥éª¤ï¼ˆrecursive stepï¼‰

é€’å½’å‡½æ•°ä¼šä»ç»™å®šçš„å€¼ä¸€ç›´è°ƒç”¨å®ƒè‡ªå·±ã€‚åœ¨è°ƒç”¨çš„è¿‡ç¨‹ä¸­ï¼Œå‡½æ•°çš„å‚æ•°ä¸æ–­å‘ç”Ÿå˜åŒ–ï¼Œå‘åŸºæœ¬æ¡ä»¶é æ‹¢ï¼Œè°ƒç”¨ä¸€ç›´åˆ°æ»¡è¶³é€’å½’çš„åŸºæœ¬æ¡ä»¶æ‰åœæ­¢ã€‚

```haskell
{-
é˜¶ä¹˜å‡½æ•°
è¿™é‡Œçš„errorå‡½æ•°ç”¨æ¥è¿”å›å¼‚å¸¸ï¼Œç”±äºç»“æœå¯ä»¥å½“åšæ—¶å¤šæ€ç±»å‹ a ï¼Œå³ String -> aï¼Œè¿™æ ·å¯ä»¥è®©è¿”å›çš„ç»“æœå’Œå…¶å®ƒäººä¸€çš„ç±»å‹ç›¸åè°ƒã€‚
-} 
factorial n | n <  0 = error "n is less that 0"
            | n == 0 = 1
            | otherwise = n * factorial (n -1)
```

```haskell
-- æœ€å¤§å…¬çº¦å‡½æ•°
import Prelude hiding (gcd)
gcd :: Int -> Int -> Int
gcd x y = if y == 0 then x  else gcd y (mod x y)
```

å½“ç„¶ï¼Œä¸€ä¸ªé€’å½’å‡½æ•°çš„åŸºæœ¬æ¡ä»¶å¯èƒ½æœ‰å¤šä¸ªã€‚åŒæ ·ï¼Œé€’å½’æ­¥éª¤ä¹Ÿå¯èƒ½ä¸æ­¢ä¸€ä¸ªã€‚



## ç®€å•é€’å½’å‡½æ•°

å®šä¹‰æˆæ–¹å‡½æ•°powerï¼Œç”±äºxâ° = 1(x â‰ 0) å’Œ xâ¿ = x Ã— xâ¿â»Â¹(nâ©¾1,xâ‰ 0)ï¼ŒæŒ‡æ•°ä¸ºè‡ªç„¶æ•°çš„ä¹˜æ–¹å¯ä»¥å®šä¹‰ä¸º

```haskell
power, power' :: Int -> Int -> Int
power 0 0 = error "cannot calculate power 0 0 "
power _ 0 = 1
power x n = x * power x (n - 1)

{-
å½“æŒ‡æ•°ä¸ºå¶æ•°ï¼Œç”±äºxÂ²â¿ = xâ¿ Ã— xâ¿ï¼Œè¿™æ · xâ¿ å°±ä¸éœ€è¦è®¡ç®—ä¸¤æ¬¡ï¼Œè€Œ n ä¸ºå¥‡æ•°æ—¶ xÂ²â¿âºÂ¹ = xâ¿ Ã— xâ¿ Ã— x
ä¼˜åŒ–åçš„power
-}
power' 0 0 = error "cannot calculate power 0 0 "
power' _ 0 = 1
power' x n | odd n = let p = power' x ((n-1) `div` 2) in x * p * p
           | otherwise = let p = power' x (n `div` 2) in p * p
```



åœ¨å®šä¹‰åŸºäºåˆ—è¡¨çš„é€’å½’å‡½æ•°æ—¶éœ€è¦è€ƒè™‘ä¸¤ç§æƒ…å½¢

1.  åˆ—è¡¨é€’å½’çš„åŸºæœ¬å®šä¹‰ï¼Œå³ []

2.  åˆ—è¡¨è‡³å°‘æœ‰ä¸€ä¸ªå…ƒç´ çš„æƒ…å½¢ï¼Œå³ x : xs ä»£æŒ‡ä½™ä¸‹çš„åˆ—è¡¨ï¼Œå¹¶ä¸”ä½™ä¸‹çš„åˆ—è¡¨å¯èƒ½ä¸ºç©º

   ```haskell
   product' [] = 1   					--(1)
   product' (x:xs) = x * product' xs 	--(2)
   ```

   åœ¨ä½¿ç”¨åˆ—è¡¨æ—¶ï¼Œ(:)ä¸ºä¸€ä¸ªå‡½æ•°ã€‚å°†ä¸€ä¸ªå…ƒç´ æ”¾åœ¨ä¸€ä¸ªåˆ—è¡¨çš„ç¬¬ä¸€ä¸ªä½ç½®ï¼Œå®ƒå¸¸å¸¸è¢«ç§°ä¸ºåˆ—è¡¨çš„æ„é€ å‡½æ•°ï¼Œåœ¨æœ‰äº›ä¹¦ä¸­å¸¸å¸¸å†™ä½œconsã€‚

   ```haskell
   > let cons = (:)
   > cons 5 [1,2,3]
   [5,1,2,3]

   -- å‡½æ•°snocï¼Œå³ cons çš„ é€†å†™
   snoc :: a -> [a] -> [a]
   snoc x [] = [x]
   snoc e (x:xs) = x : snoc e xs
   > snoc 0 [1,2,3]
   [1,2,3,0]

   -- å®ç°reverseå‡½æ•°
   reverse' :: [a] -> [a]
   reverse' [] = []
   reverse' (x:[]) = [x]
   reverse' xs = (last xs) : (reverse' (init xs))
   > reverse' [1,2,3]
   [3,2,1]

   -- å®ç°lastå‡½æ•°
   last' :: [a] -> a
   last' [] = error "empty list"
   last' [x] = x
   last' (_:xs) = last' xs
   > last' [1,2,3]
   1

   --å®ç°takeå‡½æ•°
   take' :: Int -> [a] -> [a]
   take' n _ | n <= 0 = []
   take' _ [] = []
   take' n (x:xs) = x : take' (n-1) xs
   > take' 2 [1,2,3]
   [1,2]

   --å®ç°elemå‡½æ•°
   elem' :: Eq a => a -> [a] -> Bool
   elem' _ [] = False
   elem' e (x:xs) | e == x = True
                  | otherwise = elem' e xs
   > lem' 0 [1,2,3]
   False
   > elem' 1 [1,2,3]
   True

   --å®ç° Data.List ä¸­çš„ deleteå‡½æ•°
   delete' :: Eq a => a -> [a] -> [a]
   delete' _ [] = []
   delete' e (x:xs) = if e ==x then delete' e xs else x : delete' e xs
   > delete' 2 [4,2,4,6,2]
   [4,4,6]

   --å®ç°dropå‡½æ•°
   drop' :: Int -> [a] -> [a]
   drop' _ [] = []
   drop' n (x:xs) | n <= 0 = x:xs
                  | otherwise = drop' (n - 1) xs

   ```

   â€‹

## æ‰©å±•é€’å½’ä¸å°¾é€’å½’

```haskell
-- é˜¶ä¹˜å‡½æ•°
factorial :: Int -> Int
factorial n = if n == 0 then 1 else n * factorial (n - 1)

-- æœ€å¤§å…¬çº¦å‡½æ•°
mygcd :: Int -> Int -> Int
mygcd x y = if y == 0 then x else mygcd y (mod x y)
```

- é˜¶ä¹˜å‡½æ•°åœ¨æœªè¾¾åˆ°é€’å½’çš„åŸºæœ¬æ¡ä»¶å‰ä¸€ç›´åœ¨å±•å¼€ï¼Œå¹¶ä¸èƒ½è¿›è¡Œä»»ä½•è®¡ç®—ï¼Œæ‰€æœ‰çš„ä¸­é—´ç»“æœå°†ä¼šåœ¨æš‚æ—¶å­˜å‚¨çš„å†…å­˜çš„æ ˆä¸­ï¼Œè¶Šå è¶Šå¤šã€‚è¿™æ ·çš„é€’å½’ç§°ä¸º**æ‰©å±•é€’å½’ï¼ˆaugmenting recursionï¼‰**ï¼Œå³åœ¨é€’å½’æ­¥ä¸­é™¤è°ƒç”¨é€’å½’å‡½æ•°ä»¥å¤–è¿˜å‚ä¸äº†å…¶å®ƒçš„å‡½æ•°è®¡ç®—ã€‚

- æœ€å¤§å…¬çº¦æ•°è¿™æ ·çš„å‡½æ•°ï¼Œä¸å¿…å±•å¼€å°±å¯ä»¥è®¡ç®—ï¼Œå³é™¤é€’å½’åœ°è°ƒç”¨ä»¥å¤–æ²¡æœ‰ä»»ä½•å…¶ä»–çš„å‡½æ•°è®¡ç®—ï¼Œé€’å½’è°ƒç”¨çš„ç»“æœå³ä¸ºå‡½æ•°çš„è®°è¿‡ï¼Œå³ä¾¿é€’å½’å‡½æ•°çš„å‚æ•°è¿›è¡Œäº†å…¶å®ƒçš„è®¡ç®—ï¼Œåœ¨è®¡ç®—è¿‡ç¨‹ä¸­ä¹Ÿå¯ä»¥ä¸å¿…å±•å¼€ã€‚åƒè¿™æ ·çš„é€’å½’è¢«ç§°ä¸º**å°¾é€’å½’ï¼ˆtail recursionï¼‰**ï¼Œå³åœ¨é€’å½’çš„æ—¶å€™ä¸å¿…è¦å‘å†…å­˜ä¸­æš‚å­˜ä»»ä½•å€¼ã€‚å°¾é€’å½’æ˜¯ä¸€ç§ç‰¹æ®Šçš„æƒ…å†µã€‚

  ```haskell
  -- æ‰©å±•é€’å½’
  total :: Num t => [t] -> t
  total [] = 0
  total (x:xs) = x + total xs

  {- 
  	å°¾é€’å½’å®ç°
  	å¯ä»¥çœ‹åˆ°ï¼Œåˆ©ç”¨å°¾é€’å½’å¯ä»¥å°†ä»£ç ä¼˜åŒ–ï¼Œçœå»äº†åˆ†é…ä¸´æ—¶ç©ºé—´
  	å‡½æ•°total''ä¸­çš„å‚æ•°nç§°ä¸ºç´¯ç§¯å™¨ï¼ˆaccumulatorï¼‰ã€‚é€šå¸¸ï¼Œç±»æœºå™¨çš„ç±»å‹å’Œå‡½æ•°çš„ç»“æœç±»å‹ç›¸åŒã€‚ 
  -}
  total'' :: Num t => [t] -> t -> t
  total'' [] n = n
  total'' (x:xs) n = total'' xs (x + n)
  total' xs = total'' xs 0

  {-
  	æ‰©å±•é€’å½’å’Œå°¾é€’å½’çš„å…³ç³»
  	total xs + x = total' xs x
  	
  	1ï¼Œé€’å½’åŸºæœ¬æ¡ä»¶æƒ…å†µä¸‹ä¸¤è€…çš„å…³ç³»
  	total' [] n
  	= total [] + n        {total ä¸ total' çš„ç­‰ä»·å…³ç³»}
  	= 0 + n               {åº”ç”¨åŠ æ³•å‡½æ•°}
  	= n
  	2ï¼Œé€’å½’æ­¥éª¤æƒ…å†µä¸‹ä¸¤è€…çš„å…³ç³»
  	total' (x:xs) n
  	 = (total x + x) + n  {total ä¸ total' çš„ç­‰ä»·å…³ç³»}
  	 = total xs + (x + n) {åŠ æ³•ç»“åˆå¾‹}
  	 = total' xs (x + n) {é€†ç”¨ total ä¸ total' çš„ç­‰ä»·å…³ç³»}
  -}
  ```

- è¡¨é¢ä¸Šï¼Œè¿™æ ·çš„ä¼˜åŒ–æœ¬æ¥å¯ä»¥ä½¿Haskellä¸éœ€è¦æ›´å¤šçš„ç©ºé—´ã€‚å¯æ˜¯ï¼ŒHaskellæ˜¯ä¸€ä¸ªé»˜è®¤è®¾ç½®ä¸ºæƒ°æ€§æ±‚å€¼çš„è¯­è¨€ã€‚ 

- ç”±äºæƒ°æ€§æ±‚å€¼åœ¨ä½¿ç”¨å°¾é€’å½’æ—¶ä¹Ÿå¯èƒ½ä¼šäº§å“å’Œæ‰©å±•é€’å½’ä¸€æ ·çš„é—®é¢˜ï¼Œå› æ­¤ï¼Œåœ¨ total' å‡½æ•°è°ƒç”¨åˆ°é€’å½’åŸºæœ¬æ¡ä»¶å‰ï¼Œå‚æ•° n åªå‚ä¸å’Œ x çš„åŠ æ³•è¿è¡Œï¼ŒäºŒå¹¶ä¸ä½œä¸ºç»“æœä½¿ç”¨ï¼Œå³ n çš„å…·ä½“å€¼åœ¨é€’å½’åˆ°è¾¾åŸºæœ¬æ¡ä»¶å‰ä¸éœ€è¦è¢«è®¡ç®—ã€‚å› æ­¤ï¼ŒHaskellè¿˜æ˜¯ä¼šæŠŠè¿™äº›å€¼æš‚æ—¶å­˜äºå†…å­˜ä¸­ï¼Œç­‰åˆ°éœ€è¦çš„æ—¶å€™æ‰è®¡ç®—ã€‚

  ```haskell
  {-
  total'' [1, 2, 3] 0
  =total'' [2, 3] (1 +0)
  =total'' [3] (2 + (1 +0))
  =total'' [] (3+ (2 + (1 +0)))
  =(3+ (2 + (1 +0)))
  =(3+ (2 + 1))
  =(3+ 3)
  =6
  -}
  ```

- è¿™æ ·ï¼Œéœ€è¦ä½¿ç”¨ **å¹å·æ¨¡å¼ï¼ˆbang patternï¼‰åŒ¹é…**æˆ–è€…**($!)è¿ç®—ç¬¦**æ¥å¼ºåˆ¶Haskellå¯¹ total''çš„ç¬¬äºŒä¸ªå‚æ•°è¿›è¡Œæ±‚å€¼ã€‚

  ```haskell
  total'' [] n = n
  total'' (x:xs) n = total'' xs $! (x + n)
  -- total'' (x:xs) !n = total'' xs (x + n)
  ```


- **!æ¨¡å¼**æ˜¯å¼ºåˆ¶åœ¨å‚æ•°åŒ¹é…å‰æ¥è®¡ç®—å‚æ•°çš„å€¼ï¼Œ**!æ¨¡å¼**éœ€è¦åœ¨æ–‡ä»¶é¦–æ¬¡å£°æ˜ **{-# LANGUAGE BangPatterns #-}** è¯­è¨€æ‰©å±•ã€‚è€Œ**($!)**åˆ™ä¸ºç¾è°ƒç”¨å‡½æ•°æ—¶è®¡ç®—å‚æ•°çš„å€¼ã€‚

  ```haskell
  {-
  total'' [1, 2, 3] 0
  =total'' [2, 3] (1 +0)
  =total'' [2, 3] 1
  =total'' [3] (2 + 1)
  =total'' [3] 3
  =total'' [] (3+ 3)
  =total'' [] 6
  =6
  -}
  ```

  â€‹

## äº’è°ƒé€’å½’

**äº’è°ƒé€’å½’ï¼ˆmutual recursionï¼‰**æ˜¯ä¸€ç§ç‰¹æ®Šçš„æƒ…å½¢ï¼Œå³ä¸¤ä¸ªå‡½æ•°çš„å®šä¹‰åˆ†åˆ«éƒ½ç”¨åˆ°äº†å¯¹æ–¹ã€‚

```haskell
even' 0 = True
even' n = odd' (n -1)

odd' 0 = False
odd' n = even' (n - 1)
```

è¿™ç§äº’è°ƒé€’å½’æ˜¯é—´æ¥é€’å½’çš„ä¸€ç§ç‰¹ä¾‹ã€‚

## éº¦å¡é”¡çš„91å‡½æ•°

```haskell
mc n | n > 100 = n - 10
     | otherwise = mc (mc (n + 11))
```



## æ–æ³¢é‚£å¥‘æ•°åˆ—

```haskell
-- æ€§èƒ½å·®çš„ç‰ˆæœ¬
fibonacci :: (Num a, Eq a) => a -> a -- æ•°å­—ç±»å‹çš„æ¨¡å¼åŒ¹é…éœ€è¦Eqç±»å‹ç±»
fibonacci 0 = 1
fibonacci 1 = 1
{-
è¿™ç§é€’å½’å‡½æ•°ç§°ä¸ºå¤šé‡é€’å½’ï¼ˆmultiple recursionï¼‰æˆ–è€…å¤šåˆ†æ”¯é€’å½’ã€‚
å®ƒæ˜¯ä¸€ç§ç‰¹æ®Šçš„é€’å½’ï¼Œå³ä¸€ä¸ªå‡½æ•°ä¸­é€’å½’è°ƒç”¨å¤šæ¬¡ã€‚
-}
fibonacci n = fibonacci (n - 1) + fibonacci (n - 2)

fibs n = map fibonacci [0..n-1]

-- ä¼˜åŒ–æ€§èƒ½åçš„ç‰ˆæœ¬
fibStep :: Num a => (a, a) -> (a, a)
fibStep (u, v) = (v, u + v)

fibPair :: (Num a, Eq a) => a -> (a, a)
fibPair 0 = (0, 1)
fibPair n = fibStep (fibPair (n - 1))

fastFib :: (Num a, Eq a) => a -> a
fastFib n =snd (fibPair n)

fastFibs n = map fastFib [0..n-1]

-- è¿­ä»£ç‰ˆæœ¬
fibs' n = take n (map snd (iterate fibStep (0, 1)))

-- å°¾é€’å½’ç‰ˆæœ¬
fib 0 f1 f2 = f2
fib n f1 f2 = fib (n - 1) f2 (f1 + f2)
fibonacci' n = fib n 0 1
fibs'' n = map fibonacci' [0..n-1]
```

- æ–æ³¢é‚£å¥‘æ•°åˆ—ç‰¹æ€§ï¼Œå‰ä¸€ä¸ªæ•°ä¸åä¸€ä¸ªæ•°çš„æ¯”å€¼é€¼è¿‘é»„é‡‘åˆ†å‰²å€¼ã€‚

  ```haskell
  golden :: Fractional a => Int -> [a]
  golden n = take n (map (\(x,y) -> x/y) (iterate fibStep (0, 1)))

  > golden 30
  [0.0,1.0,0.5,0.6666666666666666,0.6,0.625,0.6153846153846154,0.6190476190476191,0.6176470588235294,0.6181818181818182,0.6179775280898876,0.6180555555555556,0.6180257510729614,0.6180371352785146,0.6180327868852459,0.6180344478216818,0.6180338134001252,0.6180340557275542,0.6180339631667066,0.6180339985218034,0.618033985017358,0.6180339901755971,0.6180339882053251,0.618033988957902,0.6180339886704432,0.6180339887802427,0.618033988738303,0.6180339887543226,0.6180339887482036,0.6180339887505408]

  -- ç”¨Haskellæ¥ç²—ç•¥è®¡ç®—ä¸€ä¸‹é»„é‡‘åˆ†å‰²çš„å€¼
  > (sqrt 5 - 1) /2
  0.6180339887498949
  ```

  â€‹

- æ–æ³¢é‚£å¥‘æ•°åˆ—ç‰¹æ€§ï¼Œ4ä¸ªç›¸è¿çš„æ•´æ•°çš„å†…ç§¯å’Œå¤–ç§¯ç›¸å·®1ã€‚Fğ—‡-â‚Fğ—‡â‚Šâ‚ - (Fğ—‡)Â² = (-1)â¿

  ```haskell
  combine :: [(a,a)] ->[(a,a,a)]
  combine ((f1,f2):(f3,f4):fs) = (f1,f2,f4):combine ((f3,f4):fs)
  combine _ = []

  fibPairs :: Int -> [(Int, Int)]
  fibPairs n = map fibPair [1..n]
  > combine $ fibPairs 7
  [(1,1,2),(1,2,3),(2,3,5),(3,5,8),(5,8,13),(8,13,21)]

  difference :: Int -> [Int]
  difference n = map (\(f1,f2,f3)->f1*f3-f2*f2) (combine $ fibPairs n)
  >diffence 10
  [1,-1,1,-1,1,-1,1,-1,1]
  ```

## åè¿›åˆ¶æ•°å­—è½¬æ¢æˆç½—é©¬æ•°å­—

```haskell
romeNotation :: [String]
romeNotation = ["M","CM","D","CN","C","XC","L","XL","X","IX","V","IV","I"]

romeAmount :: [Int]
romeAmount = [1000,900,500,400,100,90,50,40,10,9,5,4,1]

pair :: [(Int, String)]
pair = zip romeAmount romeNotation

subtrahend :: Int -> (Int, String)
subtrahend n = head (dropWhile (\(a,_) -> a > n) pair)

convert :: Int -> String
convert 0 = ""
convert n = let (rome, m) = subtrahend n
                 in m ++ convert (n-rome)               
> convert 12
"XII"
> convert 109
"CIX"
> convert 4567
"MMMMDLXVII"   

{-
convert 17
= "X"   + convert(17-10)
= "XV"  + convert(7-5)
= "XV"  + convert(2)
= "XVI" + convert(2-1)
= "XVI" + convert(1)
= "XVII
-}

-- åè¿›åˆ¶è½¬äºŒè¿›åˆ¶
decimalToBinary :: Integral a => a -> String
decimalToBinary n | n < 0  = error "unsupported number"
                  | n == 0 = ""
                  | otherwise = let bit= if odd n then "1" else "0" in (decimalToBinary (n `div` 2)) ++ bit
```

##äºŒåˆ†æ³•æŸ¥æ‰¾

```haskell
-- éœ€è¦æœ‰åºçš„åˆ—è¡¨
binarySearch :: (Ord a) => a -> [a] -> Bool
binarySearch _ [] = False
binarySearch a (x:[]) = a == x
binarySearch a xs | m < a = binarySearch a behind
                  | m > a = binarySearch a front
	              | otherwise = True
	              where (front, m:behind) = splitAt (length xs `div` 2) xs

-- æŸ¥æ‰¾å¹¶è¿”å›å…ƒç´ 	        
search :: (Ord a) => a -> [a] -> [a]
search _ [] = []
search a (x:xs) | a == x  = a : search a xs
                | otherwise = search a xs
```

## æ±‰è¯ºå¡”

```haskell
{-
å‡è®¾æœ‰nä¸ªé‡‘ç‰‡çš„æ—¶å€™è¦ç§»åŠ¨ h(n) æ¬¡ã€‚

å½“æœ‰ä¸€ä¸ªé‡‘ç‰‡çš„æ—¶å€™ï¼Œç›´æ¥ç§»åŠ¨å°±å¥½äº†ï¼Œéœ€è¦ h(1) = 1 æ¬¡ã€‚

å½“æœ‰ n ä¸ªé‡‘ç‰‡çš„æ—¶å€™ï¼Œéœ€è¦å°†n - 1 ä¸ªé‡‘ç‰‡ç§»åŠ¨åˆ°éç›®æ ‡é’ˆä¸Šï¼Œéœ€è¦h(n-1)æ¬¡ã€‚è‡³äºæ€ä¹ˆç§»åŠ¨çš„ä¸éœ€è¦çŸ¥é“ï¼Œç„¶åå°†æœ€åº•ä¸‹çš„é‡‘ç‰‡ç§»åŠ¨åˆ°ç›®æ ‡é’ˆã€‚æœ€åï¼Œå†å°†éç›®æ ‡é’ˆä¸Šçš„ n-1 ä¸ªé‡‘ç‰‡åŒæ ·ç”¨å“ªä¸ªä¸éœ€è¦çŸ¥é“çš„æ–¹æ³•ç§»åŠ¨åˆ°ç›®æ ‡é’ˆä¸Šå³å¯ã€‚æ­¤æ—¶ä¹Ÿéœ€è¦ h(n-1)æ¬¡ã€‚

è¿™æ ·ï¼Œæ‰€éœ€è¦ç§»åŠ¨çš„æ€»æ¬¡æ•°ä¸º h(n) = h(n-1) + 1 + h(n-1) = 2h(n-1) + 1
-}
{-
 å‚æ•°è¯´æ˜
 é‡‘ç‰‡æ•°ï¼›ä»å“ªé‡Œç§»åŠ¨ï¼›ç§»åŠ¨åˆ°å“ªé‡Œï¼›ç§»åŠ¨è¿‡ç¨‹ä¸­å¯ä»¥å€ŸåŠ©å“ªæ ¹é’ˆ
-} 
move (1, from, to, via) = [(from, to)]
move (n, from, to, via) = move (n-1, from, via, to) ++
                         [(from, to)] ++
			 move (n-1, via, to, from)
hanoi n = move (n, 1, 2, 3)
hanoiCnt n = length $ hanoi n

hanoiCnt' 1 = 1
hanoiCnt' n = 2 * hanoiCnt'(n-1) + 1
```

## æ’åºç®—æ³•

### æ’å…¥æ’åºï¼ˆinsertion sortï¼‰

```haskell
insert, insert' :: Ord t => t -> [t] -> [t]
insert n [] = [n]
insert n a | n <= h = n : a
           | otherwise = h : (insert n t) 
	   where
	     h = head a; t = tail a
> insert 7 [5,12,10]
[5,7,10,12]

-- å°¾é€’å½’å®ç°
insert' n [] = [n]
insert' n (x:xs) | n <= x = n : x : xs
                 | otherwise = x : (insert' n xs)  
> insertionSort [] [7,5,12,10]
[5,7,10,12]

-- æ‰©å±•é€’å½’å®ç°
insertionSort' :: Ord t => [t] -> [t]
insertionSort' [] = []
insertionSort' (x:xs) = insert x (insertionSort' xs)
> insertionSort' [7,5,12,10]
[5,7,10,12]
```

### å†’æ³¡æ’åºï¼ˆbubble sortï¼‰

é€šè¿‡ä¸æ–­åœ°å°†è¾ƒå¤§çš„ç‰Œå‘å³äº¤æ¢ï¼Œé‡å¤å¤šæ¬¡å°±å¯ä»¥å¾—åˆ°ä¸€æ²“æœ‰åºçš„ç‰Œï¼Œæ¯è¿è¡Œåˆ°ç»“å°¾ï¼Œæœ€åä¸€å¼ ç‰Œæ€»æ˜¯æœ€å¤§çš„ï¼Œè¿™ä¸ªæœ€å¤§çš„è¢«ç§°ä¸ºâ€œæ³¡â€ã€‚

```haskell
-- äº¤æ¢ä¸€ä¸ªå…ƒç´ 
swaps :: Ord t => [t] -> [t]
swaps [] = []
swaps[x] = [x]
swaps (x1:x2:xs) | x1 <= x2 = x1 : swaps (x2:xs)
                 | otherwise = x2 : swaps (x1:xs)

-- å®šä¹‰ä¸€ä¸ªä¸åŠ¨ç‚¹å‡½æ•°ã€‚è¿™ä¸ªå‡½æ•°å¯ä»¥ä¸€ç›´è°ƒç”¨ swapsï¼Œä¸€åªåˆ°åˆ—è¡¨ä¸å†å‘ç”Ÿå˜åŒ–ä¸ºæ­¢
fix :: Eq a => (a -> a) -> a -> a
fix f x = if x == x' then x else fix f x'
                            where x' = f x

-- å†’æ³¡æ’åºä¸è¿‡æ˜¯ä¸€ä¸ªåå¤è°ƒç”¨ swaps çš„å‡½æ•°
bubbleSort :: Ord a => [a] -> [a]
bubbleSort xs = fix swaps xs

> bubbleSort [7,12,3,5,10]
[3,5,7,10,12]

{-
è¦é‡å¤åŒ–ç®€ä¸€ç»„æ•°æ®ï¼Œä½†æ˜¯åŒ–ç®€åçš„æ•°æ®è¿˜å¯ä»¥è¢«ç»§ç»­åŒ–ç®€ï¼Œè€…ä¸€ç±»çš„é—®é¢˜å°±å¯ä»¥äº¤ç»™ fix å‡½æ•°æ¥å¤„ç†,
å®è´¨ä¸Šä¸åŠ¨ç‚¹å‡½æ•°å¼å¯ä»¥ä»£æ›¿é¡ºåºå¼ç¼–ç¨‹è¯­è¨€ä¸­çš„å¾ªç¯çš„ã€‚
-}
-- ç›¸å½“äºæŠŠ fix éšè—åœ¨ bubbleSort' ä¸­
bubbleSort' :: Ord a => [a] -> [a]
bubbleSort' xs | swaps xs == xs = xs
               | otherwise bubbleSort' $ swaps xs
--ä¼˜åŒ–ç‰ˆæœ¬çš„å†’æ³¡æ’åº
{-
æ—¢ç„¶æœ€å¤§çš„å·²ç»è¢«äº¤æ¢åˆ°äº†æœ€å³è¾¹äº†ï¼Œå°±æ²¡æœ‰å¿…è¦å†ä½¿ç”¨äº¤æ¢å‡½æ•°äº†ã€‚å› æ­¤ï¼Œå¯ä»¥å°†äº¤æ¢å®Œæ¯•çš„åˆ—è¡¨åˆ†æˆå‰ n-1 é¡¹ä¸æœ€åä¸€é¡¹ï¼Œæœ€åä¸€é¡¹å¯ä»¥ä¸ç”¨åŠ¨äº†ï¼Œå†é€’å½’è°ƒç”¨bubbleSort''ï¼Œæ¥å¯¹å‰ n-1 é¡¹ æ’åº
-}
bubbleSort'' :: Ord a => [a] -> [a]
bubbleSort'' [] = []
bubbleSort'' xs = bubbleSort'' initialElements ++ [lastElement]
                  where swappedxs = swaps xs
		                initialElements = init swappedxs
		                lastElement = last swappedxs
```

