# 列表内包

列表内包（list comprehension），具体指的是 Haskell 提供一种精简的语法来对列表中的元素进行处理，如匹配，过滤，应用函数或者组合，这并不是 Haskell 的新功能，而仅仅只是语法糖。

## 列表生成器

```haskell
{-
  x<-[0.100] 为生成器
  x<10则是对 x 的条件限制
  x^2则对符合条件的 x 进行转换，应用平方函数，从而得到了一个新的列表
-}
>>> [x^2|x<-[0..100], x<10]
[0,1,4,9,16,25,36,49,64,81]

--生成列表的时候可以使用多个生成器，但是生成的过程是有一定的顺序的，写在后边的生成器将会被先遍历。
>>> [(x,y)|x<-[0..5],y<-"abc"]
[(0,'a'),(0,'b'),(0,'c'),(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c'),(4,'a'),(4,'b'),(4,'c'),(5,'a'),(5,'b'),(5,'c')]

--用列表生成器来定义 map 函数
map' f xs = [f x | x <- xs]

>>> map' succ [0..10]
[1,2,3,4,5,6,7,8,9,10,11]

--用列表内包来定义 filter 函数
filter' f xs = [x | x <-xs, f x]

>>> filter' even [0..10]
[0,2,4,6,8,10]

--此外，限定的条件可能不止一个，可以再加入一些限定的条件，这些限定条件之前是且的关系。
[x | x<-[0..], even x, x > 10]

--使用列表内包时，如果用不到生成器中产生的值，可以使用通配符来匹配。
length' xs = sum [1 | _ <- xs]
```

## 并列的列表内包与一般的列表内包

并列的列表内包（parallel list comprehension）相当于列表内包的一个扩展。普通的列表内包如[(x,y) | x <- [1,2,3], y <- [4,5,6]]相当于对笛卡尔积，而如果我们项得到[(1,4),  (2,5), (3,6)]就需要zipWith函数了，更为复杂的还需要使用zipWith3、zipWith4等等，但是有了并列的列表内包我就可以很容易的表达它们了。  GHC 中需要使用 ParallelListComp 语言扩展来做到：

```haskell
:set -XParallelListComp

>>> [(x,y) | x <- [1,2,3] | y <- [4,5,6]]
[(1,4),(2,5),(3,6)]
```

